<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="ffffff"><title>ZooKeeper - Session Lifetime | 笔记随想</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ZooKeeper - Session Lifetime</h1><a id="logo" href="/.">笔记随想</a><p class="description">程序员上辈子都是折翼的天使</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索..."></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">ZooKeeper - Session Lifetime</h1><div class="post-meta"><span class="date">Jun 17, 2017</span><span class="category"><a href="/categories/ZooKeeper/">ZooKeeper</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i> Hits</i></i></span><a href="/2017/06/17/ZK-session/#comments" class="comment-count"><i id="uyan_count_unit"></i>留言</a></div><div class="post-content"><p>以下描述中用<strong>zk</strong>代指<strong>ZooKeeper</strong>，源码解释均基于<strong>ZooKeeper 3.4.6</strong></p>
<h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><p>公司同事上周问了两个问题：</p>
<ul>
<li><strong>ZooKeeper Session</strong>在集群间传递吗？</li>
<li><strong>Session</strong>的<strong>expire</strong>是由<strong>Leader</strong>执行的，还是每个节点自己根据时间判断？</li>
</ul>
<p>第一个问题，必须的必啊，之前使用<strong>LogFormatter</strong>查看<strong>zk</strong>日志时：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">java -cp zookeeper-<span class="number">3.4</span>.6.jar:lib/log4j-<span class="number">1.2</span>.16.jar:lib/slf4j-log4j12-<span class="number">1.6</span>.1.jar:lib/slf4j-api-<span class="number">1.6</span>.1.jar org.apache.zookeeper.server.LogFormatter $logfile</div><div class="line"></div><div class="line">...</div><div class="line"><span class="number">5</span>/<span class="number">21</span>/<span class="number">17</span> <span class="number">9</span>:<span class="number">26</span>:<span class="number">48</span> PM CST session <span class="number">0x25c2a3ce5610001</span> cxid <span class="number">0x0</span> zxid <span class="number">0x20000000b</span> createSession <span class="number">30000</span></div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>看到了包含<strong>createSession</strong>请求的条目，所以比较确定创建<strong>Session</strong>的数据也是持久化的，而不仅仅是一个运行时的数据，这个也是<strong>zk</strong>比较奇特的一点。</p>
<h2 id="问题本身"><a href="#问题本身" class="headerlink" title="问题本身"></a>问题本身</h2><blockquote>
<p><strong>Session</strong>的<strong>expire</strong>是由<strong>Leader</strong>执行的，还是每个节点自己根据时间判断？</p>
</blockquote>
<p>如果仅仅是这一个问题，还是比较容易回答的：<strong>Session</strong>的<strong>expire</strong>是由<strong>Leader</strong>执行的。<br>对<strong>Leader</strong>进程进行<strong>jstack</strong>，结果截取如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">"SessionTracker" #28 prio=5 os_prio=31 tid=0x00007fe81e996800 nid=0x1133 in Object.wait() [0x000070001083e000]</div><div class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</div><div class="line">  at java.lang.Object.wait(Native Method)</div><div class="line">  at org.apache.zookeeper.server.SessionTrackerImpl.run(SessionTrackerImpl.java:146)</div><div class="line">  - locked &lt;0x000000076cf1b738&gt; (a org.apache.zookeeper.server.SessionTrackerImpl)</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>可以看到，<strong>Leader</strong>节点会有一个名为<strong>SessionTracker</strong>的线程执行<strong>SessionTrackerImpl.run</strong>方法。<br><strong>SessionTrackerImpl.run</strong>方法具体做的事情如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">synchronized public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">    try &#123;</div><div class="line">        <span class="keyword">while</span> (running) &#123;</div><div class="line">            // 获取当前时间，如果nextExpirationTime比当前时间要大，sleep掉这个gap，重新进入循环</div><div class="line">            currentTime = System.currentTimeMillis();</div><div class="line">            <span class="keyword">if</span> (nextExpirationTime &gt; currentTime) &#123;</div><div class="line">                this.wait(nextExpirationTime - currentTime);</div><div class="line">                <span class="built_in">continue</span>;</div><div class="line">            &#125;</div><div class="line">            // sessionSets是一个Map，key是一个时间戳t1，value是一个session的集合，</div><div class="line">            // 集合里面session的过期时间都为t1</div><div class="line">            SessionSet <span class="built_in">set</span>;</div><div class="line">            <span class="built_in">set</span> = sessionSets.remove(nextExpirationTime);</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">set</span> != null) &#123;</div><div class="line">                <span class="keyword">for</span> (SessionImpl s : set.sessions) &#123;</div><div class="line">                    // 设置session的状态为closing</div><div class="line">                    setSessionClosing(s.sessionId);</div><div class="line">                    // 调用expirer.expire来关闭session，这个时候会把closeSession的日志同步到其它节点</div><div class="line">                    // 会有Info级别日志：“Expiring session ... , timeout of xxx ms exceeded” 产生</div><div class="line">                    expirer.expire(s);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            // 更新nextExpirationTime，expirationInterval就是conf/zoo.cfg里面定义的tickTime</div><div class="line">            // 所以删除过期session的精度就是tickTime</div><div class="line">            nextExpirationTime += expirationInterval;</div><div class="line">        &#125;</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        LOG.error(<span class="string">"Unexpected interruption"</span>, e);</div><div class="line">    &#125;</div><div class="line">    LOG.info(<span class="string">"SessionTrackerImpl exited loop!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>问题回答到这里，显然是不够的。从我的角度，能看到延伸问题如下：</p>
<ul>
<li><strong>sessionId</strong>是如何构造的，如何保证唯一性</li>
<li>什么请求会触发更新<strong>Session</strong>的过期时间</li>
<li>如果客户端是连接到<strong>Follower</strong>的，<strong>Leader</strong>如何更新<strong>Session</strong>的过期时间</li>
<li>如果发生了重新选举，<strong>Leader</strong>更换之后，新的<strong>Leader</strong>是如何导入<strong>Session</strong>信息的</li>
<li><strong>Session</strong>和<strong>Ephemeral Node</strong>是如何结合的</li>
<li>清除过期<strong>Session</strong>的时候，会删除掉对应的<strong>Ephemeral Node</strong>么</li>
<li><strong>createSession</strong>操作完整的处理流程是怎样的</li>
</ul>
<h2 id="延伸问题"><a href="#延伸问题" class="headerlink" title="延伸问题"></a>延伸问题</h2><h2 id="问题A"><a href="#问题A" class="headerlink" title="问题A"></a>问题A</h2><blockquote>
<p><strong>sessionId</strong>是如何构造的，如何保证唯一性</p>
</blockquote>
<p><strong>zk</strong>日志中<strong>createSession</strong>时会打印出如下的日志：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Established session 0x15c30814aef0000 with negotiated timeout 30000 <span class="keyword">for</span><span class="built_in"> client </span>/x.x.x.x:60915</div></pre></td></tr></table></figure></p>
<p>上面这条日志中，<strong>sessionId</strong>为<strong>0x15c30814aef0000</strong>。在<strong>zk</strong>日志中，<strong>sessionId</strong>的类型为<strong>long</strong>，那么这个<strong>64位</strong>的数据是如何组成的，如何保证唯一性的呢？<br>依然是<strong>SessionTrackerImpl</strong>这个类中，有<strong>initializeNextSession</strong>这个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">initializeNextSession</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> nextSid = <span class="number">0</span>;</div><div class="line">    nextSid = (System.currentTimeMillis() &lt;&lt; <span class="number">24</span>) &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    nextSid =  nextSid | (id &lt;&lt;<span class="number">56</span>);</div><div class="line">    <span class="keyword">return</span> nextSid;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以，<strong>sessionId</strong>的构造如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">|<span class="number">63</span>...<span class="number">56</span>|<span class="number">55</span>...................................<span class="number">16</span>|<span class="number">15</span>............<span class="number">0</span>|</div><div class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">|  myid |                  timestamp            |    counter    |</div><div class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div></pre></td></tr></table></figure></p>
<p>对于<strong>sessionId</strong>这个<strong>64位</strong>的数据，<strong>高8位</strong>代表创建<strong>Session</strong>时所在的<strong>zk</strong>节点的<strong>id</strong>；<strong>中间40位</strong>代表<strong>zk节点</strong>当前角色（<strong>Leader</strong>或者<strong>Learner</strong>）在创建的时候的时间戳；<strong>低16位</strong>是一个计数器，初始值为<strong>0</strong>。<br>再看看上面日志里面的<strong>sessionId：0x15c30814aef0000</strong>：</p>
<ul>
<li><strong>高8位，0x1</strong>，代表这个<strong>Session</strong>是在<strong>myid=1</strong>的<strong>zk</strong>节点上面创建的</li>
<li><strong>中间40位，0x5c30814aef</strong>，代表<strong>myid=1</strong>的<strong>zk</strong>节点在初始化的时候时间戳的<strong>低40位</strong>是<strong>0x5c30814aef</strong></li>
<li><strong>低16位，0x0000</strong>，代表这是<strong>myid=1</strong>的<strong>zk</strong>节点在当前状态创建的第<strong>1</strong>个<strong>Session</strong><br>每个角色（<strong>Leader</strong>或者<strong>Learner</strong>）在构造的时候，都会调用<strong>createSessionTracker</strong>来创建一个<strong>SessionTracker</strong>对象。<br>这时候就会调用<strong>SessionTrackerImpl.initializeNextSession</strong>来设置<strong>nextSessionId</strong>。<br>初始设置完之后，每次通过<strong>createSession</strong>来获取<strong>sessionId</strong>时，所做的动作仅仅是进行<strong>nextSessionId++</strong>。</li>
</ul>
<h2 id="问题B"><a href="#问题B" class="headerlink" title="问题B"></a>问题B</h2><blockquote>
<p>什么请求会触发更新<strong>Session</strong>的过期时间</p>
</blockquote>
<p>客户端的任何请求都会触发更新<strong>Session</strong>的过期时间，包括客户端维持心跳的<strong>ping</strong>请求。<br><strong>Session</strong>过期时间的更新是在<strong>ZooKeeperServer.touch</strong>中进行的，通过<strong>BTrace</strong>可以拿到<strong>ZooKeeperServer.touch</strong>的调用栈如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.ZooKeeperServer</span><span class="selector-class">.touch</span>(ZooKeeperServer.java)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.ZooKeeperServer</span><span class="selector-class">.submitRequest</span>(ZooKeeperServer<span class="selector-class">.java</span>:<span class="number">667</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.ZooKeeperServer</span><span class="selector-class">.processPacket</span>(ZooKeeperServer<span class="selector-class">.java</span>:<span class="number">942</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.NIOServerCnxn</span><span class="selector-class">.readRequest</span>(NIOServerCnxn<span class="selector-class">.java</span>:<span class="number">373</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.NIOServerCnxn</span><span class="selector-class">.readPayload</span>(NIOServerCnxn<span class="selector-class">.java</span>:<span class="number">200</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.NIOServerCnxn</span><span class="selector-class">.doIO</span>(NIOServerCnxn<span class="selector-class">.java</span>:<span class="number">244</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.NIOServerCnxnFactory</span><span class="selector-class">.run</span>(NIOServerCnxnFactory<span class="selector-class">.java</span>:<span class="number">208</span>)</div><div class="line">java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread<span class="selector-class">.java</span>:<span class="number">745</span>)</div></pre></td></tr></table></figure></p>
<p>除了四字命令，客户端所有的访问操作都会触发<strong>Session</strong>更新过期时间。<br>再看看<strong>ZooKeeperServer.touch</strong>都会做哪些事情：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void touch(ServerCnxn cnxn) throws MissingSessionException &#123;</div><div class="line">    <span class="keyword">if</span> (cnxn == null) &#123;</div><div class="line">        <span class="built_in">return</span>;</div><div class="line">    &#125;</div><div class="line">    long id = cnxn.getSessionId();</div><div class="line">    int to = cnxn.getSessionTimeout();</div><div class="line">    <span class="keyword">if</span> (!sessionTracker.touchSession(id, to)) &#123;</div><div class="line">        throw new MissingSessionException(</div><div class="line">                <span class="string">"No session with sessionid 0x"</span> + Long.toHexString(id)</div><div class="line">                + <span class="string">" exists, probably expired and removed"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>ZooKeeperServer.touch</strong>其实只是调用了<strong>sessionTracker.touchSession</strong>来进行<strong>Session</strong>过期时间的更新。对于<strong>Leader</strong>和<strong>Learner</strong>这两个不同的角色，使用的<strong>sessionTracker</strong>的实现是不同的：</p>
<ul>
<li><strong>Leader</strong>使用的是<strong>SessionTrackerImpl</strong></li>
<li><strong>Learner</strong>使用的是<strong>LearnerSessionTracker</strong></li>
</ul>
<p>更新<strong>Session</strong>的过期时间其实都是在<strong>Leader</strong>中进行的，毕竟<strong>expire</strong>操作也是由<strong>Leader</strong>来执行的，所以这里只看<strong>SessionTrackerImpl</strong>中<strong>touchSession</strong>的实现：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">synchronized public boolean touchSession(long sessionId, int timeout) &#123;</div><div class="line">    <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</div><div class="line">        ZooTrace.logTraceMessage(LOG,</div><div class="line">                                 ZooTrace.CLIENT_PING_TRACE_MASK,</div><div class="line">                                 <span class="string">"SessionTrackerImpl --- Touch session: 0x"</span></div><div class="line">                + Long.toHexString(sessionId) + <span class="string">" with timeout "</span> + timeout);</div><div class="line">    &#125;</div><div class="line">    // 根据sessionId来获取session结构，如果不存在，或者已经是closing状态，说明对应的session已经过期</div><div class="line">    // 返回<span class="literal">false</span></div><div class="line">    SessionImpl s = sessionsById.get(sessionId);</div><div class="line">    <span class="keyword">if</span> (s == null || s.isClosing()) &#123;</div><div class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    // 如果session存在，计算出这个session下一次的过期时间</div><div class="line">    // roundToInterval保证计算出来的过期时间会是SessionTrackerImpl.expirationInterval的整数倍</div><div class="line">    // 像前面提到的，SessionTrackerImpl.expirationInterval的值就是conf/zoo.cfg里面定义的tickTime</div><div class="line">    long expireTime = roundToInterval(System.currentTimeMillis() + timeout);</div><div class="line">    // 如果session当前的过期时间比计算出来的时间还要大，直接返回<span class="literal">true</span>，这个可能是因为session的timeout设置变小了</div><div class="line">    <span class="keyword">if</span> (s.tickTime &gt;= expireTime) &#123;</div><div class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    // 下面的操作就是更新sessionSets，这样就不会在之前的过期时间s.tickTime的时候被过期掉了</div><div class="line">    SessionSet <span class="built_in">set</span> = sessionSets.get(s.tickTime);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">set</span> != null) &#123;</div><div class="line">        set.sessions.remove(s);</div><div class="line">    &#125;</div><div class="line">    // 更新session的过期时间</div><div class="line">    s.tickTime = expireTime;</div><div class="line">    <span class="built_in">set</span> = sessionSets.get(s.tickTime);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">set</span> == null) &#123;</div><div class="line">        <span class="built_in">set</span> = new SessionSet();</div><div class="line">        sessionSets.put(expireTime, <span class="built_in">set</span>);</div><div class="line">    &#125;</div><div class="line">    set.sessions.add(s);</div><div class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="问题C"><a href="#问题C" class="headerlink" title="问题C"></a>问题C</h2><blockquote>
<p>如果客户端是连接到<strong>Follower</strong>的，<strong>Leader</strong>如何更新<strong>Session</strong>的过期时间</p>
</blockquote>
<p>刚才<strong>问题B</strong>里面提到了<strong>Learner</strong>使用的是<strong>LearnerSessionTracker</strong>，所以再来看一下<strong>LearnerSessionTracker.touchSession</strong>的实现：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">synchronized public boolean touchSession(long sessionId, int sessionTimeout) &#123;</div><div class="line">    touchTable.put(sessionId, sessionTimeout);</div><div class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>似不似很简单，只有一次<strong>HashMap</strong>操作；<strong>touchTable</strong>会在<strong>LearnerSessionTracker.snapshot</strong>中使用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">synchronized HashMap&lt;Long, Integer&gt; <span class="function"><span class="title">snapshot</span></span>() &#123;</div><div class="line">    HashMap&lt;Long, Integer&gt; oldTouchTable = touchTable;</div><div class="line">    touchTable = new HashMap&lt;Long, Integer&gt;();</div><div class="line">    <span class="built_in">return</span> oldTouchTable;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过<strong>BTrace</strong>可以拿到<strong>LearnerSessionTracker.snapshot</strong>的调用栈如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.LearnerSessionTracker</span><span class="selector-class">.snapshot</span>(LearnerSessionTracker.java)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.LearnerZooKeeperServer</span><span class="selector-class">.getTouchSnapshot</span>(LearnerZooKeeperServer<span class="selector-class">.java</span>:<span class="number">58</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.Learner</span><span class="selector-class">.ping</span>(Learner<span class="selector-class">.java</span>:<span class="number">525</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.Follower</span><span class="selector-class">.processPacket</span>(Follower<span class="selector-class">.java</span>:<span class="number">112</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.Follower</span><span class="selector-class">.followLeader</span>(Follower<span class="selector-class">.java</span>:<span class="number">86</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.QuorumPeer</span><span class="selector-class">.run</span>(QuorumPeer<span class="selector-class">.java</span>:<span class="number">786</span>)</div></pre></td></tr></table></figure></p>
<p>可以看到<strong>Follower</strong>会在收到<strong>Leader</strong>发送过来的<strong>ping</strong>请求之后，把<strong>touchTable</strong>中的内容放在<strong>response</strong>之中，传回给<strong>Leader</strong>。<br>那么<strong>Leader</strong>收到<strong>Follower</strong>的<strong>ping response</strong>之后会怎么处理呢？<br>对应的逻辑在<strong>LearnerHandler.run</strong>中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> Leader.PING:</div><div class="line">    ByteArrayInputStream bis = new ByteArrayInputStream(qp</div><div class="line">            .getData());</div><div class="line">    DataInputStream dis = new DataInputStream(bis);</div><div class="line">    <span class="keyword">while</span> (dis.available() &gt; 0) &#123;</div><div class="line">        // sess为follower传过来的sessionId</div><div class="line">        long sess = dis.readLong();</div><div class="line">        // to为follower传过来的sessionId对应的timeout</div><div class="line">        int to = dis.readInt();</div><div class="line">        // 这里调用ZooKeeperServer.touch来更新session过期时间</div><div class="line">        leader.zk.touch(sess, to);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">break</span>;</div></pre></td></tr></table></figure></p>
<p>可以看到，<strong>Leader</strong>会把回包中的<strong>sessionId</strong>都<strong>touch</strong>一遍。<br><strong>Leader</strong>对<strong>Follower</strong>进行<strong>ping</strong>的时间间隔是多少呢？<br>如果间隔太大，可能导致<strong>Leader</strong>中<strong>Session</strong>的过期时间更新得不及时，导致<strong>Session</strong>信息被删除掉。<br>对应的逻辑在<strong>Leader.lead</strong>中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    // 等待 self.tickTime / 2 的时间</div><div class="line">    // 以tickTime为2s为例，这里leader对follower进行ping的时间间隔为1s</div><div class="line">    // 前面提到了session的过期时间会是expirationInterval的整数倍，expirationInterval就是tickTime</div><div class="line">    // 也就是说在leader连续两次检查session过期的间隔期间，至少会对follower进行一次ping操作</div><div class="line">    Thread.sleep(self.tickTime / 2);</div><div class="line">    ...</div><div class="line">    // 这里会对所有的Learner进行ping</div><div class="line">    <span class="keyword">for</span> (LearnerHandler f : getLearners()) &#123;</div><div class="line">        // Synced <span class="built_in">set</span> is used to check we have a supporting quorum, so only</div><div class="line">        // PARTICIPANT, not OBSERVER, learners should be used</div><div class="line">        <span class="keyword">if</span> (f.synced() &amp;&amp; f.getLearnerType() == LearnerType.PARTICIPANT) &#123;</div><div class="line">            syncedSet.add(f.getSid());</div><div class="line">        &#125;</div><div class="line">        f.ping();</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从代码中可以看到，<strong>ping</strong>的间隔足够小，不会导致<strong>Leader</strong>中<strong>Session</strong>的过期时间更新不及时。</p>
<h2 id="问题D"><a href="#问题D" class="headerlink" title="问题D"></a>问题D</h2><blockquote>
<p>如果发生了重新选举，<strong>Leader</strong>更换之后，新的<strong>Leader</strong>是如何导入<strong>session</strong>信息的</p>
</blockquote>
<p>奥秘就在<strong>SessionTrackerImpl</strong>的构造方法里面：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public SessionTrackerImpl(SessionExpirer expirer,</div><div class="line">            ConcurrentHashMap&lt;Long, Integer&gt; sessionsWithTimeout, int tickTime,</div><div class="line">            long sid)</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    this.sessionsWithTimeout = sessionsWithTimeout;</div><div class="line">    nextExpirationTime = roundToInterval(System.currentTimeMillis());</div><div class="line">    this.nextSessionId = initializeNextSession(sid);</div><div class="line">    <span class="keyword">for</span> (Entry&lt;Long, Integer&gt; e : sessionsWithTimeout.entrySet()) &#123;</div><div class="line">        addSession(e.getKey(), e.getValue());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，<strong>SessionTrackerImpl</strong>会遍历参数里面的<strong>sessionsWithTimeout</strong>，调用<strong>addSession</strong>重建<strong>sessionsById、sessionSets、sessionsWithTimeout</strong>这些用来管理<strong>session</strong>的数据结构。<br>新<strong>Leader</strong>上位会大赦天下，在<strong>addSession</strong>里面把所有的<strong>session</strong>全部<strong>touch</strong>一遍。<br>再回过头去看，新<strong>Leader</strong>是如何去创建<strong>SessionTrackerImpl</strong>对象的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">org.apache.zookeeper.server.SessionTrackerImpl.&lt;init&gt;(SessionTrackerImpl.java:97)</div><div class="line">org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.createSessionTracker(LeaderZooKeeperServer.java:81)</div><div class="line">org.apache.zookeeper.server.ZooKeeperServer.startup(ZooKeeperServer.java:405)</div><div class="line">org.apache.zookeeper.server.quorum.Leader.startZkServer(Leader.java:947)</div><div class="line">org.apache.zookeeper.server.quorum.Leader.lead(Leader.java:418)</div><div class="line">org.apache.zookeeper.server.quorum.QuorumPeer.run(QuorumPeer.java:799)</div></pre></td></tr></table></figure></p>
<p>具体是在<strong>ZooKeeperServer.createSessionTracker</strong>中创建<strong>SessionTrackerImpl</strong>对象的。<br><strong>ZooKeeperServer.createSessionTracker</strong>逻辑如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protected void <span class="function"><span class="title">createSessionTracker</span></span>() &#123;</div><div class="line">    sessionTracker = new SessionTrackerImpl(this, zkDb.getSessionWithTimeOuts(),</div><div class="line">            tickTime, 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么，<strong>zkDb.getSessionWithTimeOuts()</strong>是如何通过现在的数据进行<strong>sessionsWithTimeout</strong>的重建的呢？<br>逻辑在<strong>ZKDatabase.loadDataBase</strong>中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public long loadDataBase() throws IOException &#123;</div><div class="line">    PlayBackListener listener=new <span class="function"><span class="title">PlayBackListener</span></span>()&#123;</div><div class="line">        public void onTxnLoaded(TxnHeader hdr,Record txn)&#123;</div><div class="line">            Request r = new Request(null, 0, hdr.getCxid(),hdr.getType(),</div><div class="line">                    null, null);</div><div class="line">            r.txn = txn;</div><div class="line">            r.hdr = hdr;</div><div class="line">            r.zxid = hdr.getZxid();</div><div class="line">            addCommittedProposal(r);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    long zxid = snapLog.restore(dataTree,sessionsWithTimeouts,listener);</div><div class="line">    initialized = <span class="literal">true</span>;</div><div class="line">    <span class="built_in">return</span> zxid;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>综上，新<strong>Leader</strong>在进行<strong>Leader.lead()</strong>时，会先调用<strong>zk.loadData()</strong>把数据从持久化文件（<strong>snapshot/log</strong>）中恢复出<strong>sessionsWithTimeout</strong>，然后调用<strong>startZkServer</strong>创建<strong>SessionTrackerImpl</strong>重构<strong>session</strong>相关的数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">void lead() throws IOException, InterruptedException &#123;</div><div class="line">    self.end_fle = System.currentTimeMillis();</div><div class="line">    LOG.info(<span class="string">"LEADING - LEADER ELECTION TOOK - "</span> +</div><div class="line">          (self.end_fle - self.start_fle));</div><div class="line">    self.start_fle = 0;</div><div class="line">    self.end_fle = 0;</div><div class="line"></div><div class="line">    zk.registerJMX(new LeaderBean(this, zk), self.jmxLocalPeerBean);</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        self.tick = 0;</div><div class="line">        zk.loadData();</div><div class="line">        ...</div><div class="line">        startZkServer();</div><div class="line">        ...</div><div class="line">    &#125; finally &#123;</div><div class="line">        zk.unregisterJMX(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="问题E"><a href="#问题E" class="headerlink" title="问题E"></a>问题E</h2><blockquote>
<p><strong>Session</strong>和<strong>Ephemeral Node</strong>是如何结合的</p>
</blockquote>
<p>在<strong>PrepRequestProcessor.pRequest2Txn</strong>中，可以看到下面的逻辑：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> OpCode.create:<span class="type"></span></div><div class="line">    ...</div><div class="line">    <span class="comment">// 首先判断创建的Znode的parent是否为ephemeral，如果是，直接抛出异常</span></div><div class="line">    <span class="comment">// 因为 Ephemerals cannot have children，临时节点是不能有子节点的</span></div><div class="line">    boolean ephemeralParent = parentRecord.stat.getEphemeralOwner() != <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (ephemeralParent) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">KeeperException</span>.NoChildrenForEphemeralsException(path);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 更新新的cversion</span></div><div class="line">    int <span class="keyword">new</span><span class="type">Cversion</span> = parentRecord.stat.getCversion()+<span class="number">1</span>;</div><div class="line">    request.txn = <span class="keyword">new</span> <span class="type">CreateTxn</span>(path, createRequest.getData(),</div><div class="line">            listACL,</div><div class="line">            createMode.isEphemeral(), <span class="keyword">new</span><span class="type">Cversion</span>);</div><div class="line">    StatPersisted s = <span class="keyword">new</span> <span class="type">StatPersisted</span>();</div><div class="line">    <span class="keyword">if</span> (createMode.isEphemeral()) &#123;</div><div class="line">        <span class="comment">// 这里会关连ephemeral node和相关的session信息</span></div><div class="line">        s.setEphemeralOwner(request.sessionId);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 深拷贝出来一个parentRecord，设置一些相关的信息</span></div><div class="line">    parentRecord = parentRecord.duplicate(request.hdr.getZxid());</div><div class="line">    parentRecord.childCount++;</div><div class="line">    parentRecord.stat.setCversion(<span class="keyword">new</span><span class="type">Cversion</span>);</div><div class="line">    addChangeRecord(parentRecord);</div><div class="line">    addChangeRecord(<span class="keyword">new</span> <span class="type">ChangeRecord</span>(request.hdr.getZxid(), path, s,</div><div class="line">            <span class="number">0</span>, listACL));</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<p>在<strong>Znode</strong>创建的过程，就会设置<strong>Znode</strong>对应的<strong>Ephemeral Owner</strong>。</p>
<h2 id="问题F"><a href="#问题F" class="headerlink" title="问题F"></a>问题F</h2><blockquote>
<p>清除过期<strong>Session</strong>的时候，会删除掉对应的<strong>Ephemeral Node</strong>么</p>
</blockquote>
<p>清除过期<strong>Session</strong>，最终会调用关闭<strong>Session</strong>的操作，<strong>ZooKeeperServer.close</strong>的逻辑如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">long</span> sessionId)</span> </span>&#123;</div><div class="line">    submitRequest(<span class="keyword">null</span>, sessionId, OpCode.closeSession, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再看看<strong>zk</strong>请求收到<strong>OpCode.closeSession</strong>时，是如何处理的。<br>同样在<strong>PrepRequestProcessor.pRequest2Txn</strong>中（<strong>PrepRequestProcessor</strong>处理了很多与<strong>zk api</strong>语义相关的逻辑），可以看到：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> OpCode.<span class="string">closeSession:</span></div><div class="line">    <span class="comment">// We don't want to do this check since the session expiration thread</span></div><div class="line">    <span class="comment">// queues up this operation without being the session owner.</span></div><div class="line">    <span class="comment">// this request is the last of the session so it should be ok</span></div><div class="line">    <span class="comment">//zks.sessionTracker.checkSession(request.sessionId, request.getOwner());</span></div><div class="line">    HashSet&lt;String&gt; es = zks.getZKDatabase()</div><div class="line">            .getEphemerals(request.sessionId);</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (zks.outstandingChanges) &#123;</div><div class="line">        <span class="keyword">for</span> (ChangeRecord <span class="string">c :</span> zks.outstandingChanges) &#123;</div><div class="line">            <span class="keyword">if</span> (c.stat == <span class="literal">null</span>) &#123;</div><div class="line">                <span class="comment">// Doing a delete</span></div><div class="line">                es.remove(c.path);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c.stat.getEphemeralOwner() == request.sessionId) &#123;</div><div class="line">                es.add(c.path);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (String <span class="string">path2Delete :</span> es) &#123;</div><div class="line">            addChangeRecord(<span class="keyword">new</span> ChangeRecord(request.hdr.getZxid(),</div><div class="line">                    path2Delete, <span class="literal">null</span>, <span class="number">0</span>, <span class="literal">null</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        zks.sessionTracker.setSessionClosing(request.sessionId);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到：<br><strong>Leader</strong>收到<strong>OpCode.closeSession</strong>请求之后（<strong>PrepRequestProcessor</strong>只会存在于<strong>Leader</strong>中），会找出<strong>zKDatabase</strong>中所有和这个<strong>Session</strong>相关的<strong>Ephemeral Node</strong>的路径。<br>另外，还会找出<strong>zks.outstandingChanges</strong>里面，<strong>EphemeralOwner</strong>设置为当前<strong>session</strong>的所有路径。<br>然后把所有这些路径都调用<strong>addChangeRecord</strong>添加到<strong>zks.outstandingChanges</strong>中。<br>但是这些并非真正地应用到内存中的<strong>DataTree</strong>上，真正的删除节点的操作并不在这里。之前在<strong>zk</strong>日志里面发现过这样的记录：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Deleting ephemeral <span class="keyword">node</span> <span class="title">/mypath</span> for session <span class="number">0</span>x153501f0a4a05cb</div></pre></td></tr></table></figure></p>
<p>这行日志打印由方法<strong>DataTree.killSession</strong>打印的：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">void killSession(<span class="keyword">long</span> session, <span class="keyword">long</span> zxid) &#123;</div><div class="line">    <span class="comment">// the list is already removed from the ephemerals</span></div><div class="line">    <span class="comment">// so we do not have to worry about synchronizing on</span></div><div class="line">    <span class="comment">// the list. This is only called from FinalRequestProcessor</span></div><div class="line">    <span class="comment">// so there is no need for synchronization. The list is not</span></div><div class="line">    <span class="comment">// changed here. Only create and delete change the list which</span></div><div class="line">    <span class="comment">// are again called from FinalRequestProcessor in sequence.</span></div><div class="line">    HashSet&lt;String&gt; <span class="keyword">list</span> = ephemerals.remove(session);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">list</span> != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (String path : <span class="keyword">list</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                deleteNode(path, zxid);</div><div class="line">                <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</div><div class="line">                    LOG</div><div class="line">                            .debug(<span class="string">"Deleting ephemeral node "</span> + path</div><div class="line">                                    + <span class="string">" for session 0x"</span></div><div class="line">                                    + <span class="keyword">Long</span>.toHexString(session));</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (NoNodeException e) &#123;</div><div class="line">                LOG.warn(<span class="string">"Ignoring NoNodeException for path "</span> + path</div><div class="line">                        + <span class="string">" while removing ephemeral for dead session 0x"</span></div><div class="line">                        + <span class="keyword">Long</span>.toHexString(session));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用栈如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.DataTree</span><span class="selector-class">.killSession</span>(DataTree.java)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.DataTree</span><span class="selector-class">.processTxn</span>(DataTree<span class="selector-class">.java</span>:<span class="number">818</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.ZKDatabase</span><span class="selector-class">.processTxn</span>(ZKDatabase<span class="selector-class">.java</span>:<span class="number">329</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.ZooKeeperServer</span><span class="selector-class">.processTxn</span>(ZooKeeperServer<span class="selector-class">.java</span>:<span class="number">994</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.FinalRequestProcessor</span><span class="selector-class">.processRequest</span>(FinalRequestProcessor<span class="selector-class">.java</span>:<span class="number">116</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.Leader</span><span class="variable">$ToBeAppliedRequestProcessor</span>.processRequest(Leader<span class="selector-class">.java</span>:<span class="number">644</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.CommitProcessor</span><span class="selector-class">.run</span>(CommitProcessor<span class="selector-class">.java</span>:<span class="number">74</span>)</div></pre></td></tr></table></figure></p>
<p>删掉<strong>Ephemeral Node</strong>到底意味着什么，和删除<strong>Persistent Node</strong>是一样的么？<br>关闭<strong>Session</strong>的时候删除<strong>Ephemeral Node</strong>会应用到日志里面么？<br>带着上面的疑问，使用<strong>zkCli.sh</strong>连接到<strong>server</strong>，创建<strong>Ephemeral Node</strong>，然后退出。<br>观察到<strong>log</strong>如下：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">5/24/17 1</span>:<span class="number">57</span>:<span class="number">56</span> PM CST session <span class="number">0</span>x15c38d<span class="number">9b8000001</span> cxid <span class="number">0</span>x0 zxid <span class="number">0x100000004</span> createSession <span class="number">30000</span></div><div class="line"><span class="number">5/24/17 1</span>:<span class="number">58</span>:<span class="number">20</span> PM CST session <span class="number">0</span>x15c38d<span class="number">9b8000001</span> cxid <span class="number">0</span>x1 zxid <span class="number">0x100000005</span> create '/ephemeral,#<span class="number">6</span>b6b6b,v&#123;s&#123;<span class="number">31</span>,s&#123;'world,'anyone&#125;&#125;&#125;,T,<span class="number">2</span></div><div class="line"><span class="number">5/24/17 1</span>:<span class="number">58</span>:<span class="number">53</span> PM CST session <span class="number">0</span>x15c38d<span class="number">9b8000001</span> cxid <span class="number">0</span>x2 zxid <span class="number">0x100000006</span> closeSession null</div></pre></td></tr></table></figure></p>
<p>可见，关闭<strong>Session</strong>的时候删除<strong>Ephemeral Node</strong>并不会应用到日志中，只会从内存的<strong>DataTree</strong>中删除对应的数据。删除<strong>DataTree</strong>中数据的逻辑在<strong>DataTree.deleteNode</strong>。<br>关于<strong>DataTree</strong>，我觉得有一个很有意思的地方，从<strong>DataTree</strong>的<strong>javadoc</strong>里面可以看到：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">* The tree maintains <span class="literal">two</span> parallel data structures: <span class="keyword">a</span> hashtable that maps <span class="built_in">from</span></div><div class="line">* full paths <span class="built_in">to</span> DataNodes <span class="keyword">and</span> <span class="keyword">a</span> tree <span class="keyword">of</span> DataNodes. All accesses <span class="built_in">to</span> <span class="keyword">a</span> path is</div><div class="line">* through <span class="keyword">the</span> hashtable. The tree is traversed only when serializing <span class="built_in">to</span> disk.</div></pre></td></tr></table></figure></p>
<p><strong>javadoc</strong>说的是，维护了两个数据结构，一个是全路径到<strong>DataNode</strong>的映射（<strong>DataTree.nodes</strong>这个<strong>field</strong>），另外一个是所有<strong>DataNode</strong>的<strong>tree</strong>（<strong>DataTree.root</strong>这个<strong>field</strong>）。然而，这个<strong>tree</strong>呢，和我们传统意义上的<strong>tree</strong>（至少我们写二叉树实现的时候）是不太一样的：<strong>DataNode</strong>里面并没有指针/对象指向所有的子节点，仅仅有所有子节点的路径。<br>所以节点对象的定位，都是通过<strong>DataTree.nodes</strong>来查找的。所以删除<strong>Ephemeral Node</strong>，只需要删除这个<strong>Znode</strong>在<strong>DataTree.nodes</strong>中的条目即可。</p>
<h2 id="问题G"><a href="#问题G" class="headerlink" title="问题G"></a>问题G</h2><blockquote>
<p><strong>createSession</strong>操作完整的处理流程是怎样的</p>
</blockquote>
<p>这个问题再描述具体点：如果应用使用<strong>zk</strong>客户端连接到<strong>zk</strong>集群的一个<strong>Follower</strong>结点，那么会是一个什么逻辑呢？<br><strong>Follower</strong>的处理<br>请求到达<strong>Follower</strong>后，<strong>Follower</strong>会调用<strong>ZooKeeperServer.submitRequest</strong>，然后会调用<strong>firstProcessor.processRequest</strong>，对于<strong>Follower</strong>来说，<strong>ZooKeeperServer</strong>的实现是<strong>FollowerZooKeeperServer</strong>，这个实现里面的<strong>firstProcessor</strong>为<strong>FollowerReqeustProcessor</strong>。<br>对于不同的<strong>ZooKeeperServer</strong>子类来说，比较重要的是<strong>setupRequestProcessors</strong>这个方法，<strong>setupRequestProcessors</strong>这个方法会去生成某个角色的处理链，<strong>Standalone、Follower、Leader</strong>这三种角色的处理链都是各有不同的（<strong>Observer</strong>这个角色在我们的部署中没有，暂时偷懒忽略:)）。<br>对于<strong>Follower</strong>来说，主线处理链是：<br><strong>FollowerReqeustProcessor</strong> =&gt; <strong>CommitProcessor</strong> =&gt; <strong>FinalRequestProcessor</strong><br>另外，还有一条辅线处理链：<br><strong>SyncReqeustProcessor</strong> =&gt; <strong>SendAckRequestProcessor</strong><br>下面逐个来讲解下这几种<strong>RequestProcessor</strong>。</p>
<h2 id="主线处理链"><a href="#主线处理链" class="headerlink" title="主线处理链"></a>主线处理链</h2><p><strong>FollowerReqeustProcessor</strong>是<strong>Follower</strong>专有的<strong>RequestProcessor</strong>，会做两件事情：</p>
<ul>
<li>把收到的情况一股脑儿地传给<strong>nextProcessor</strong>，也就是<strong>CommitRequestProcessor</strong></li>
<li>调用<strong>zks.getFollower().request(request)</strong>把写请求转发给<strong>Leader</strong></li>
</ul>
<hr>
<p><strong>CommitProcessor</strong>比较重要，<strong>follower</strong>和<strong>leader</strong>的处理链都有它。<br>它的名字比较特殊，<strong>RequestProcessor</strong>接口所有的实现里面，就它名字特殊，其它实现类名的<strong>suffix</strong>都是<strong>RequestProcessor</strong>，就它不是，当然，这是我纯扯淡:)。<br><strong>CommitProcessor</strong>里面有两个队列：<strong>queuedRequests</strong>和<strong>committedRequests</strong>。<strong>queuedRequests</strong>里面是所有应用过来的请求，<strong>committedRequests</strong>里面是所有已经被<strong>committed</strong>的请求。只有<strong>CommitProcessor.commit</strong>这个方法会往<strong>committedRequests</strong>这个队列添加元素，而<strong>CommitProcessor.commit</strong>的调用有以下两个地方：</p>
<ul>
<li>在<strong>Follower</strong>中，Follower.processPacket方法中收到<strong>Leader</strong>发过来的<strong>Leader.COMMIT</strong>会调用<strong>FollowerZooKeeperServer.commit</strong>，然后会调用<strong>CommitProcessor.commit</strong></li>
<li>在<strong>Leader</strong>中，<strong>Leader.processAck</strong>中如果收到<strong>Ack</strong>的个数达到了大多数会调用<strong>CommitProcessor.commit；Leader.processAck</strong>有两个调用的地方：</li>
<li>处理<strong>Leader</strong>自己的<strong>Ack</strong>，在<strong>AckRequestProcessor.processRequest</strong>中（<strong>AckRequestProcessor</strong>是<strong>leader</strong>专有的）会调用</li>
<li>处理<strong>Follower</strong>回复的<strong>Ack</strong>，在<strong>LearnerHandler.run</strong>中处理<strong>Follower</strong>发来的<strong>Leader.ACK</strong>请求时会调用</li>
</ul>
<p>好，扯远了，收回来。<strong>CommitProcessor.run</strong>的<strong>loop</strong>逻辑如下：</p>
<ul>
<li>对<strong>toProcess</strong>队列里面的所有请求调用<strong>nextProcessor.processRequest</strong>，也就是<strong>FinalRequestProcessor.processRequest</strong>，<strong>toProcess</strong>队列只有读请求和已经<strong>committed</strong>的写请求</li>
<li>如果<strong>committedRequests</strong>中有请求，就把这个请求拉出来，和当前的<strong>nextPending</strong>（<strong>nextPending</strong>可以理解为当前正在等<strong>commit</strong>的写请求）对比，如果匹配，就把<strong>nextPending</strong>放入<strong>toProcess</strong>队列中，并清空<strong>nextPending</strong></li>
<li>如果<strong>nextPending</strong>不为空，说明有写请求还在等<strong>commit</strong>，不用处理<strong>queuedRequests</strong>队列里面的请求了，重新进入<strong>loop</strong></li>
<li>处理<strong>queuedRequests</strong>队列里面的请求，如果是写操作，设置<strong>nextPending</strong>，重新进入<strong>loop</strong>；如果是读操作，添加到<strong>toProcess</strong>队列中，有多少添加多少</li>
</ul>
<p>通过以上逻辑可以看到写请求是会阻塞后面的读请求的，所以，如果对一致性要求不是那么强的读请求，<strong>zk</strong>的访问有必要做读写分离呢？</p>
<p><strong>FinalRequestProcessor</strong>也是一个比较重要的角儿，<strong>Standalone、Follower、Leader</strong>这三种角色的处理链中都有它的存在，到达这个<strong>RequestProcessor</strong>的请求和放在<strong>CommitProcessor.toProcess</strong>一样，只有读请求和已经<strong>committed</strong>的写请求。<br><strong>FinalRequestProcessor</strong>会做两件事情：</p>
<ul>
<li>操作<strong>ZooKeeperServer.zkDb</strong></li>
<li>返回<strong>response</strong>给客户端</li>
</ul>
<h2 id="辅线处理链"><a href="#辅线处理链" class="headerlink" title="辅线处理链"></a>辅线处理链</h2><p><strong>SyncReqeustProcessor</strong>也是比较重要的，和<strong>FinalRequestProcessor</strong>一样，也是<strong>Standalone、Follower、Leader</strong>这三种角色都会有的。这个<strong>RequestProcessor</strong>其实只做一件事情：写日志，可以认为是两阶段提交的第一阶段。<br><strong>SyncReqeustProcessor.processRequest</strong>有两个调用的地方：</p>
<ul>
<li>在<strong>Follower</strong>中，<strong>Follower.processPacket</strong>方法中收到<strong>Leader</strong>发过来的<strong>Leader.PROPOSAL</strong>会调用<strong>FollowerZooKeeperServer.logRequest</strong>，然后会调用<strong>SyncReqeustProcessor.processRequest</strong></li>
<li>在<strong>Leader</strong>中，<strong>ProposalRequestProcessor.processRequest</strong>对于写操作，不仅会<strong>zks.getLeader().propose(request)</strong>通知所有<strong>Follower</strong>去写日志，还会调用<strong>SyncReqeustProcessor.processRequest</strong>来写入<strong>Leader</strong>自己的本地日志。</li>
</ul>
<p><strong>SendAckRequestProcessor</strong>是<strong>Follower</strong>专有的<strong>RequestProcessor</strong>，也是唯一实现了<strong>Flushable</strong>接口的<strong>RequestProcessor</strong>。做的事情比较纯粹，给<strong>Leader</strong>回一个<strong>Leader.ACK</strong>的<strong>QuorumPacket</strong>。</p>
<h2 id="Leader的处理"><a href="#Leader的处理" class="headerlink" title="Leader的处理"></a>Leader的处理</h2><p>上述<strong>Follower</strong>的处理中，我们提到了<strong>FollowerRequestProcessor</strong>会：</p>
<blockquote>
<p>调用<strong>zks.getFollower().request(request)</strong>把写请求转发给<strong>Leader</strong></p>
</blockquote>
<p>从这一刻开始，<strong>Leader</strong>的处理开始登上历史舞台。<br>在<strong>LearnerHandler.run</strong>中收到<strong>Leader.REQUEST</strong>，会调用<strong>leader.zk.submitRequest(si)</strong>，代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="type">Leader</span>.<span class="type">REQUEST</span>:</div><div class="line">    bb = <span class="type">ByteBuffer</span>.wrap(qp.getData());</div><div class="line">    sessionId = bb.getLong();</div><div class="line">    cxid = bb.getInt();</div><div class="line">    <span class="class"><span class="keyword">type</span> </span>= bb.getInt();</div><div class="line">    bb = bb.slice();</div><div class="line">    <span class="type">Request</span> si;</div><div class="line">    <span class="comment">// 对于OpCode.sync请求，会创建一个不一样的包，LearnerSyncRequest</span></div><div class="line">    <span class="keyword">if</span>(<span class="class"><span class="keyword">type</span> <span class="title">==</span> <span class="title">OpCode</span>.<span class="title">sync</span>)</span>&#123;</div><div class="line">        si = <span class="keyword">new</span> <span class="type">LearnerSyncRequest</span>(<span class="keyword">this</span>, sessionId, cxid, <span class="class"><span class="keyword">type</span>, <span class="title">bb</span>, <span class="title">qp</span>.<span class="title">getAuthinfo</span>(<span class="params"></span>))</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        si = <span class="keyword">new</span> <span class="type">Request</span>(<span class="literal">null</span>, sessionId, cxid, <span class="class"><span class="keyword">type</span>, <span class="title">bb</span>, <span class="title">qp</span>.<span class="title">getAuthinfo</span>(<span class="params"></span>))</span>;</div><div class="line">    &#125;</div><div class="line">    si.setOwner(<span class="keyword">this</span>);</div><div class="line">    <span class="comment">// 这里会调用submitRequest，让LeaderZooKeeperServer来处理请求</span></div><div class="line">    leader.zk.submitRequest(si);</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<p>上面讲<strong>Follower</strong>的处理时，提到了：</p>
<blockquote>
<p>请求到达<strong>Follower</strong>后，<strong>Follower</strong>会调用<strong>ZooKeeperServer.submitRequest</strong>，然后会调用<strong>firstProcessor.processRequest</strong></p>
</blockquote>
<p><strong>Leader</strong>和<strong>Follower</strong>一样，都会调用<strong>ZooKeeperServer.submitRequest</strong>，这里面逻辑是一样的，区别在于处理链不一样。<strong>Leader</strong>的处理链是所有角色中最复杂的，涉及到7个<strong>RequestProcessor</strong>，如下图所示：<br><a href="http://orimyicvd.bkt.clouddn.com/Request.png" data-fancybox="images" target="_blank" rel="external"><img src="http://orimyicvd.bkt.clouddn.com/Request.png"></a><br><strong>CommitProcessor、SyncRequestProcessor、FinalRequestProcessor</strong>都是老熟人了，在上面刚见过。下面介绍下另外的4个<strong>RequestProcessor</strong>。<br><strong>PrepRequestProcessor</strong>并非是<strong>Leader</strong>专有的，<strong>Standalone</strong>模式也会有。这个<strong>RequestProcessor</strong>也是所有<strong>RequestProcessor</strong>实现中最复杂的，从这个类对应代码文件的行数就可以看出来：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">find * -name <span class="string">'*Processor.java'</span>  |xargs wc -l |sort -k <span class="number">1</span></div><div class="line">   <span class="number">44</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server/RequestProcessor.java</div><div class="line">   <span class="number">48</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server/UnimplementedRequestProcessor.java</div><div class="line">   <span class="number">54</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server<span class="regexp">/quorum/</span>AckRequestProcessor.java</div><div class="line">   <span class="number">80</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server<span class="regexp">/quorum/</span>SendAckRequestProcessor.java</div><div class="line">   <span class="number">93</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server<span class="regexp">/quorum/</span>ProposalRequestProcessor.java</div><div class="line">  <span class="number">112</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server<span class="regexp">/quorum/</span>FollowerRequestProcessor.java</div><div class="line">  <span class="number">126</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server<span class="regexp">/quorum/</span>ObserverRequestProcessor.java</div><div class="line">  <span class="number">128</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server<span class="regexp">/quorum/</span>ReadOnlyRequestProcessor.java</div><div class="line">  <span class="number">192</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server<span class="regexp">/quorum/</span>CommitProcessor.java</div><div class="line">  <span class="number">235</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server/SyncRequestProcessor.java</div><div class="line">  <span class="number">418</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server/FinalRequestProcessor.java</div><div class="line">  <span class="number">766</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server/PrepRequestProcessor.java</div></pre></td></tr></table></figure></p>
<p>复杂也是正常的，毕竟与<strong>zk api</strong>语义相关的逻辑基本都在这里实现的。<br><strong>PrepRequestProcessor.pRequest</strong>是这个<strong>RequestProcessor</strong>最重要的实现，这个方法里面做两件事情：</p>
<ul>
<li>调用<strong>pRequest2Txn</strong>设置部分请求的<strong>request.hdr</strong>和<strong>request.txn</strong>，<strong>pRequest2Txn</strong>里面会完成一些接口语义相关的逻辑，比如上面提到的，收到<strong>OpCode.create</strong>请求时会去设置<strong>Ephemeral Owner</strong></li>
<li>调用<strong>nextProcessor.processRequest</strong>，也就是<strong>ProposalRequestProcessor.processRequest</strong></li>
</ul>
<p><strong>ProposalRequestProcessor</strong>是<strong>Leader</strong>专有的<strong>RequestProcessor</strong>，会做三件事情：</p>
<ul>
<li>调用<strong>nextProcessor.processRequest</strong>，也就是<strong>CommitProcessor.processRequest</strong></li>
<li>对于设置了<strong>request.hdr</strong>的请求，调用<strong>zks.getLeader().propose(request)</strong>向所有的<strong>Follower</strong>发送<strong>Leader.PROPOSAL</strong>请求。上面的描述中提到了<strong>Follower</strong>收到<strong>Leader</strong>发送过来的<strong>Leader.PROPOSAL</strong>请求后，最终会调用<strong>SyncReqeustProcessor.processRequest</strong>去写入日志。那么<strong>Leader</strong>自己的日志什么时候写呢，就在下一步了。</li>
<li>对于设置了<strong>request.hdr</strong>的请求，调用<strong>syncProcessor.processRequest</strong>来向<strong>Leader</strong>自己的日志里写入记录。这里会有疑问，什么是”设置了<strong>request.hdr</strong>的请求”呢？除了<strong>create、delete、setData、setACL、multi、createSession、closeSession</strong>这些常见的写操作之外，还有一个<strong>check</strong>。</li>
</ul>
<p><strong>ToBeAppliedRequestProcessor</strong>是<strong>Leader</strong>专有的<strong>RequestProcessor</strong>，也是唯一一个内部类的<strong>RequestProcessor</strong>。做的事情非常简单，只是在<strong>CommitProcessor</strong>和<strong>FinalRequestProcessor</strong>之前做个桥接。唯一的作用在于维护一个<strong>toBeApplied</strong>的队列，这个队列里面包括了已经达到<strong>quorum</strong>，但是还没有应用到<strong>FinalRequestProcessor</strong>的<strong>Proposal</strong>。</p>
<p><strong>AckRequestProcessor</strong>是<strong>Leader</strong>专有的<strong>RequestProcessor</strong>，和<strong>Follower</strong>专有的<strong>SendAckRequestProcessor</strong>长得很像，做的逻辑也比较类似。调用<strong>leader.processAck</strong>，相当于写一个本地的<strong>Ack</strong>。<br>综上所述，<strong>CreateSession</strong>操作完整的处理流程如下图：<br><a href="http://orimyicvd.bkt.clouddn.com/CreateSession.png" data-fancybox="images" target="_blank" rel="external"><img src="http://orimyicvd.bkt.clouddn.com/CreateSession.png"></a></p>
<h2 id="选做题"><a href="#选做题" class="headerlink" title="选做题"></a>选做题</h2><p>分享这个问题的时候遇到两个问题，我不太能回答上来，想请大家帮我解答一下：</p>
<ul>
<li>为什么不能统一地从<strong>Leader</strong>拿<strong>sessionId</strong>？其实想想，也是可以的，只是<strong>createSession</strong>是<strong>synchronized</strong>，在<strong>Follower</strong>上操作能稍微提高一些并发。</li>
<li>为什么大量使用<strong>synchronized</strong>，而不是使用锁？<strong>zk</strong>的代码里面，确实是非常大量地使用<strong>synchronized</strong>。只是因为<strong>zk</strong>不是很注重性能，使用<strong>synchronized</strong>会使代码看起来更易懂一些么。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.tonyseek.com/post/zookeeper-sessionid/" target="_blank" rel="external">https://blog.tonyseek.com/post/zookeeper-sessionid/</a></li>
<li><a href="http://damacheng009.iteye.com/blog/2085968" target="_blank" rel="external">http://damacheng009.iteye.com/blog/2085968</a></li>
<li><a href="http://agapple.iteye.com/blog/1292129" target="_blank" rel="external">http://agapple.iteye.com/blog/1292129</a></li>
<li><a href="http://stackoverflow.com/questions/17894808/how-do-one-read-the-zookeeper-transaction-log" target="_blank" rel="external">http://stackoverflow.com/questions/17894808/how-do-one-read-the-zookeeper-transaction-log</a></li>
</ul>
</div><div class="tags"><a href="/tags/ZooKeeper/">ZooKeeper</a></div><div class="post-share"><div data-thread-key="2017/06/17/ZK-session/" data-title="ZooKeeper - Session Lifetime" data-url="https://hackbuteers.github.io/2017/06/17/ZK-session/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到:</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2017/06/18/ZooKeeper/" class="pre">ZooKeeper - 从懵逼到淡定</a><a href="/2017/06/14/ZK-Data-Sync/" class="next">ZooKeeper - Data Sync</a></div><div id="comments"><div id="uyan_frame"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、背景"><span class="toc-text">1、背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题本身"><span class="toc-text">问题本身</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#延伸问题"><span class="toc-text">延伸问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题A"><span class="toc-text">问题A</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题B"><span class="toc-text">问题B</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题C"><span class="toc-text">问题C</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题D"><span class="toc-text">问题D</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题E"><span class="toc-text">问题E</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题F"><span class="toc-text">问题F</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题G"><span class="toc-text">问题G</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主线处理链"><span class="toc-text">主线处理链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#辅线处理链"><span class="toc-text">辅线处理链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Leader的处理"><span class="toc-text">Leader的处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选做题"><span class="toc-text">选做题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/16/Springboot加载自定义容器/">spring-boot加载自定义容器</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/16/spring-boot启动解读/">spring-boot启动解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/28/package-conflict/">JAVA - jar包冲突</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/18/Storm集群的搭建/">Storm集群的搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/18/Apache-Kafka2/">Apache_Kafka入门（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/18/Apache-Kafka1/">Apache_Kafka入门（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/18/ZooKeeper/">ZooKeeper - 从懵逼到淡定</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/17/ZK-session/">ZooKeeper - Session Lifetime</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/ZK-Data-Sync/">ZooKeeper - Data Sync</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/tongji/">Hexo添加百度统计流程</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IDEA/">IDEA</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kafka/">Kafka</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Boot/">Spring Boot</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ZooKeeper/">ZooKeeper</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/ZooKeeper/" style="font-size: 15px;">ZooKeeper</a> <a href="/tags/Spring-Boot/" style="font-size: 15px;">Spring Boot</a> <a href="/tags/IDEA/" style="font-size: 15px;">IDEA</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/JAVA/" style="font-size: 15px;">JAVA</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.cnblogs.com/tengj/category/809716.html" title="hexo干货系列" target="_blank">hexo干货系列</a><ul></ul><a href="http://www.cnblogs.com/zhcncn/p/4097881.html" title="Hexo搭建Github静态博客" target="_blank">Hexo搭建Github静态博客</a><ul></ul><a href="http://blog.csdn.net/hackbuteer1" title="csdn" target="_blank">csdn</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">hackbuteer.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?08d029a331c2c9bec74ec1505f1df8ab";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script src="http://v2.uyan.cc/code/uyan.js?uid=2137468"></script></body></html>
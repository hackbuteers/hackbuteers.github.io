<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>笔记随想</title>
  <subtitle>dddddd</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hackbuteers.github.io/"/>
  <updated>2017-06-14T13:45:40.000Z</updated>
  <id>https://hackbuteers.github.io/</id>
  
  <author>
    <name>hackbuteer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ZooKeeper - Data Sync</title>
    <link href="https://hackbuteers.github.io/2017/06/14/ZK-Data-Sync/"/>
    <id>https://hackbuteers.github.io/2017/06/14/ZK-Data-Sync/</id>
    <published>2017-06-14T09:11:33.000Z</published>
    <updated>2017-06-14T13:45:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下描述中用<strong>zk</strong>代指<strong>ZooKeeper</strong>，源码解释均基于<strong>ZooKeeper 3.4.6</strong></p>
<h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><p>继上次的<strong>Session</strong>问题后，好学的小冷同学又认真地研究了下<strong>ZooKeeper Cluster</strong>的原理，问了我下面5个问题：</p>
<blockquote>
<ul>
<li><strong>ZooKeeper</strong>集群在发生<strong>Leader</strong>切换的时候，所有的<strong>Follower</strong>会选择新的<strong>Leader</strong>进行全量的数据同步吗？</li>
<li>如果一次写入，由于丢包，导致某条日志没有写入，会怎么样呢？</li>
<li>扩容的时候加了个节点，这时候新的写入会不会同步到这个新节点呢？</li>
<li><strong>Follower</strong>会主动向<strong>Leader</strong>发<strong>ping</strong>包么？</li>
<li>集群在选举的时候，四字命令都会返回<strong>This ZooKeeper instance is not currently serving requests</strong>，什么时候会变回正常可服务状态？</li>
</ul>
</blockquote>
<p>这几个问题我都不太确定，于是，踏上了新一轮的<strong>啃码之旅</strong>。</p>
<h2 id="问题A"><a href="#问题A" class="headerlink" title="问题A"></a>问题A</h2><blockquote>
<p><strong>ZooKeeper</strong>集群在发生<strong>Leader</strong>切换的时候，所有的<strong>Follower</strong>会选择新的<strong>Leader</strong>进行全量的数据同步吗？</p>
</blockquote>
<p>这篇帖子里面的解释是我比较认同：</p>
<blockquote>
<p>1、SNAP-全量同步<br>条件：peerLastZxid<mincommittedlog 说明：证明二者数据差异太大，follower数据过于陈旧，leader发送快照snap指令给follower全量同步数据，即leader将所有数据全量同步到follower="" 2、diff-增量同步="" 条件：mincommittedlog<="peerLastZxid<=maxCommittedLog" 说明：证明二者数据差异不大，follower上有一些leader上已经提交的提议proposal未同步，此时需要增量提交这些提议即可="" 3、trunc-仅回滚同步="" 条件：peerlastzxid="">minCommittedLog<br>说明：证明follower上有些提议proposal并未在leader上提交，follower需要回滚到zxid为minCommittedLog对应的事务操作<br>4、TRUNC+DIFF-回滚+增量同步<br>条件：minCommittedLog&lt;=peerLastZxid&lt;=maxCommittedLog且特殊场景leader a已经将事务truncA提交到本地事务日志中，但没有成功发起proposal协议进行投票就宕机了；然后集群中剔除原leader a重新选举出新leader b，又提交了若干新的提议proposal，然后原leader a重新服务又加入到集群中，不管是否被选举为新leader。<br>说明：此时a,b都有一些对方未提交的事务，若b是leader, a需要先回滚truncA然后增量同步新leader a上的数据</mincommittedlog></p>
</blockquote>
<p>对应的代码在<strong>LearnerHandler.run</strong>中：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// packetToSend默认为Leader.SNAP</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    rl.<span class="built_in">lock</span>();</div><div class="line">    final long maxCommittedLog = <span class="built_in">leader</span>.zk.getZKDatabase().getmaxCommittedLog();</div><div class="line">    final long minCommittedLog = <span class="built_in">leader</span>.zk.getZKDatabase().getminCommittedLog();</div><div class="line">    <span class="built_in">LOG</span>.info(<span class="string">"Synchronizing with Follower sid: "</span> + sid</div><div class="line">            +<span class="string">" maxCommittedLog=0x"</span>+Long.toHexString(maxCommittedLog)</div><div class="line">            +<span class="string">" minCommittedLog=0x"</span>+Long.toHexString(minCommittedLog)</div><div class="line">            +<span class="string">" peerLastZxid=0x"</span>+Long.toHexString(peerLastZxid));</div><div class="line"></div><div class="line">    <span class="comment">// ZKDatabase.committedLog是仅存在于内存中的结构，虽然Follower或者Leader退出时，</span></div><div class="line">    <span class="comment">// 会调用ZKDatabase.clear清空内存中的数据，但是FastLeaderElection.getInitLastLoggedZxid</span></div><div class="line">    <span class="comment">// 最终会调用ZKDatabase.loadDataBase重新加载数据到ZKDatabase.committedLog等内存结构中</span></div><div class="line">    <span class="comment">// 当然，ZKDatabase.loadDataBase是把日志文件中的内容加载加这个结构中</span></div><div class="line">    <span class="comment">// 如果加载之前，对应的zk节点刚好是新生成的snapshot，就会导致ZKDatabase.committedLog为空</span></div><div class="line">    LinkedList&lt;Proposal&gt; proposals = <span class="built_in">leader</span>.zk.getZKDatabase().getCommittedLog();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (proposals.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">LOG</span>.debug(<span class="string">"proposal size is &#123;&#125;"</span>, proposals.<span class="built_in">size</span>());</div><div class="line">        <span class="keyword">if</span> ((maxCommittedLog &gt;= peerLastZxid)</div><div class="line">                &amp;&amp; (minCommittedLog &lt;= peerLastZxid)) &#123;</div><div class="line">            <span class="comment">// 如果Follower的zxid在[minCommittedLog, maxCommittedLog]，说明可能可以通过重新应用Follower上没有的事务日志来恢复数据</span></div><div class="line">            <span class="built_in">LOG</span>.debug(<span class="string">"Sending proposals to follower"</span>);</div><div class="line"></div><div class="line">            <span class="comment">// as we look through proposals, this variable keeps track of previous</span></div><div class="line">            <span class="comment">// proposal Id.</span></div><div class="line">            long prevProposalZxid = minCommittedLog;</div><div class="line"></div><div class="line">            <span class="comment">// Keep track of whether we are about to send the first packet.</span></div><div class="line">            <span class="comment">// Before sending the first packet, we have to tell the learner</span></div><div class="line">            <span class="comment">// whether to expect a trunc or a diff</span></div><div class="line">            boolean firstPacket=<span class="literal">true</span>;</div><div class="line"></div><div class="line">            <span class="comment">// If we are here, we can use committedLog to sync with</span></div><div class="line">            <span class="comment">// follower. Then we only need to decide whether to</span></div><div class="line">            <span class="comment">// send trunc or not</span></div><div class="line">            packetToSend = <span class="built_in">Leader</span>.DIFF;</div><div class="line">            zxidToSend = maxCommittedLog;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (Proposal propose: proposals) &#123;</div><div class="line">                <span class="comment">// 遍历ZKDatabase.committedLog中的事务日志，跳过那些已经在Follower上应用过的日志</span></div><div class="line">                <span class="comment">// skip the proposals the peer already has</span></div><div class="line">                <span class="keyword">if</span> (propose.packet.getZxid() &lt;= peerLastZxid) &#123;</div><div class="line">                    prevProposalZxid = propose.packet.getZxid();</div><div class="line">                    continue;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// If we are sending the first packet, figure out whether to trunc</span></div><div class="line">                    <span class="comment">// in case the follower has some proposals that the leader doesn't</span></div><div class="line">                    <span class="keyword">if</span> (firstPacket) &#123;</div><div class="line">                        firstPacket = <span class="literal">false</span>;</div><div class="line">                        <span class="comment">// Does the peer have some proposals that the leader hasn't seen yet</span></div><div class="line">                        <span class="keyword">if</span> (prevProposalZxid &lt; peerLastZxid) &#123;</div><div class="line">                            <span class="comment">// send a trunc message before sending the diff</span></div><div class="line">                            <span class="comment">// 如果出现这种情况，我们需要先在Follower上应用Leader.TRUNC，让其回滚到prevProposalZxid的位置</span></div><div class="line">                            packetToSend = <span class="built_in">Leader</span>.TRUNC;</div><div class="line">                            zxidToSend = prevProposalZxid;</div><div class="line">                            updates = zxidToSend;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 下面这几行语句是针对Follower上没有的事务日志构造出PROPOSAL和COMMIT请求，放到队列中</span></div><div class="line">                    <span class="comment">// 可以注意到，这个时候LearnerHandler的发送线程是还没有启动的，所以对应的FOLLOWER肯定是先响应Leader.DIFF或者Leader.TRUNC请求的</span></div><div class="line">                    queuePacket(propose.packet);</div><div class="line">                    QuorumPacket qcommit = new QuorumPacket(<span class="built_in">Leader</span>.COMMIT, propose.packet.getZxid(),</div><div class="line">                            null, null);</div><div class="line">                    queuePacket(qcommit);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (peerLastZxid &gt; maxCommittedLog) &#123;</div><div class="line">            <span class="comment">// 如果Follower的zxid比当前的Leader还要大，发送Leader.TRUNC让Follower的事务日志回滚到当前Leader的maxCommittedLog</span></div><div class="line">            <span class="comment">// 和Leader.SNAP一样，Leader.TRUNC会导致对应的Follower调用ZKDatabase.loadDataBase重新加载数据到内存中</span></div><div class="line">            <span class="built_in">LOG</span>.debug(<span class="string">"Sending TRUNC to follower zxidToSend=0x&#123;&#125; updates=0x&#123;&#125;"</span>,</div><div class="line">                    Long.toHexString(maxCommittedLog),</div><div class="line">                    Long.toHexString(updates));</div><div class="line"></div><div class="line">            packetToSend = <span class="built_in">Leader</span>.TRUNC;</div><div class="line">            zxidToSend = maxCommittedLog;</div><div class="line">            updates = zxidToSend;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 进入这块代码的条件是peerLastZxid&lt;minCommittedLog，使用默认的packetToSend：Leader.SNAP</span></div><div class="line">            <span class="comment">// 这个条件有一个case：在zk集群中加入一个新的节点，这时候如果Leader        的事务日志中有内容，就会进入这个情况</span></div><div class="line">            <span class="built_in">LOG</span>.warn(<span class="string">"Unhandled proposal scenario"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (peerLastZxid == <span class="built_in">leader</span>.zk.getZKDatabase().getDataTreeLastProcessedZxid()) &#123;</div><div class="line">        <span class="comment">// 如果ZKDatabase.committedLog为空，而且对应的Follower和当前Leader内存中的数据是一致的，只发送一个Leader.DIFF的请求</span></div><div class="line">        <span class="comment">// 而不进行数据的同步，甚至也没有对应的PROPOSAL/COMMIT请求</span></div><div class="line">        <span class="comment">// The leader may recently take a snapshot, so the committedLog</span></div><div class="line">        <span class="comment">// is empty. We don't need to send snapshot if the follow</span></div><div class="line">        <span class="comment">// is already sync with in-memory db.</span></div><div class="line">        <span class="built_in">LOG</span>.debug(<span class="string">"committedLog is empty but leader and follower "</span></div><div class="line">                + <span class="string">"are in sync, zxid=0x&#123;&#125;"</span>,</div><div class="line">                Long.toHexString(peerLastZxid));</div><div class="line">        packetToSend = <span class="built_in">Leader</span>.DIFF;</div><div class="line">        zxidToSend = peerLastZxid;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 如果ZKDatabase.committedLog为空，但是对应的Follower和当前Leader内存中的数据不一致</span></div><div class="line">        <span class="comment">// 这时候会使用默认的packetToSend：Leader.SNAP</span></div><div class="line">        <span class="comment">// just let the state transfer happen</span></div><div class="line">        <span class="built_in">LOG</span>.debug(<span class="string">"proposals is empty"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">LOG</span>.info(<span class="string">"Sending "</span> + <span class="built_in">Leader</span>.getPacketType(packetToSend));</div><div class="line">    leaderLastZxid = <span class="built_in">leader</span>.startForwarding(this, updates);</div><div class="line"></div><div class="line">&#125; finally &#123;</div><div class="line">    rl.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="问题B"><a href="#问题B" class="headerlink" title="问题B"></a>问题B</h2><blockquote>
<p>如果一次写入，由于丢包，导致某条日志没有写入，会怎么样呢？</p>
</blockquote>
<p>先引入上次的<strong>Session</strong>问题中使用过的一张图：<br><a href="https://orimyicvd.bkt.clouddn.com/zk-session.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/zk-session.png"></a><br><strong>Leader</strong>会向<strong>Follower</strong>发送<strong>Proposal</strong>和<strong>Commit</strong>请求，其中，<strong>Follower</strong>收到<strong>Proposal</strong>请求之后，会写入日志；收到<strong>Commit</strong>请求之后，会更改内存中的<strong>DataTree</strong>。<br>问题中提到的日志没有写入，也就是发送到某个<strong>Follower</strong>的<strong>Proposal</strong>请求被丢弃了， 对应的<strong>Follower</strong>会是怎样一个逻辑呢？<br>回答这个问题，最直观的方法就是模拟场景，在实验中将<strong>Proposal</strong>请求丢弃，观察对应的<strong>Follower</strong>和<strong>Leader</strong>的表现。<br>那么，问题来了，如何模拟呢？<br>在<strong>Jepsen</strong>中，使用的是<strong>iptables</strong>来模拟网络故障（周期性地丢包、网络分区等）。在我的模拟环境中，<strong>zk</strong>集群都是部署在本地，使用<strong>iptables</strong>来操作会比较繁琐，而且我的需求是精确地丢弃掉<strong>Proposal</strong>请求，而不是<strong>Follower</strong>和<strong>Leader</strong>之间发送的所有的请求。<br>最终还是使用了<strong>Byteman</strong>，对应的脚本如下：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">RULE trace zk.skip_proposal_packet</div><div class="line"><span class="keyword">CLASS</span> org.apache.zookeeper.server.quorum.Follower</div><div class="line"><span class="function"><span class="keyword">METHOD</span> <span class="title">processPacket</span></span></div><div class="line"><span class="title">AT</span> <span class="title">ENTRY</span></div><div class="line"><span class="title">IF</span> $1.<span class="title">getType</span><span class="params">()</span> == 2</div><div class="line"><span class="title">DO</span></div><div class="line">  <span class="title">traceln</span><span class="params">("*** drop PROPOSAL packet")</span>;</div><div class="line">  return;</div><div class="line">ENDRULE</div></pre></td></tr></table></figure></p>
<p>使用<strong>Byteman</strong>做故障场景模拟并不是我的原创，<strong>Cassandra</strong>中使用了<strong>Byteman</strong>来做故障场景注入。这种方法的优点是可以完成代码级别在精确错误注入；缺点也很明显，需要待注入服务是运行在<strong>JVM</strong>之上的。<br>进行了场景模拟之后，发现被测的丢弃<strong>Proposal</strong>请求的<strong>Follower</strong>进入了<strong>LOOKING</strong>状态，然后重新加入了集群。原因是<strong>Leader</strong>主动断开了和<strong>Proposal</strong>的连接。<br>那么，为什么<strong>Follower</strong>丢弃<strong>Proposal</strong>请求会导致<strong>Leader</strong>主动断开了和<strong>Proposal</strong>的连接呢？<br>这个逻辑和<strong>LearnerHandler$SyncLimitCheck</strong>有关，<strong>Leader</strong>会定时去调用<strong>LearnerHandler.ping</strong>向<strong>Follower</strong>发送<strong>Leader.PING</strong>请求，逻辑如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void ping() &#123;</div><div class="line">    long id;</div><div class="line">    <span class="keyword">if</span> (syncLimitCheck.check(System.nanoTime())) &#123;</div><div class="line">        synchronized(leader) &#123;</div><div class="line">            id = leader.lastProposed;</div><div class="line">        &#125;</div><div class="line">        QuorumPacket<span class="built_in"> ping </span>= new QuorumPacket(Leader.PING, id, <span class="literal">null</span>, <span class="literal">null</span>);</div><div class="line">        queuePacket(ping);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        LOG.warn(<span class="string">"Closing connection to peer due to transaction timeout."</span>);</div><div class="line">        shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果<strong>Leader</strong>发送出去的<strong>Leader.PROPOSAL</strong>请求在一段时间内（这个时间由<strong>conf/zoo.cfg</strong>中的<strong>syncLimit</strong>决定）没有收到对应的<strong>ACK</strong>，就会导致<strong>syncLimitCheck.check</strong>失败，从而调用LearnerHandler.shutdown关闭到这个Follower的连接，并停止对应的发送、接收请求的线程。<br>在Follower这边，由于Leader连接关闭，调用Learner.readPacket时会抛出异常，退出Follower.followLeader方法，重新进入LOOKING状态。<br>综上，我们知道了，发送到某个Follower的Proposal请求被丢弃，会导致对应的Follower重新进入LOOKING状态。<br>那么，如果被丢弃的请求是Commit请求呢？<br>同样使用Byteman进行了模拟，由于Commit请求是不需要返回ACK给Leader的，所以，如果模拟时有两个写入请求ReqA、ReqB，如果两个请求对应的Commit请求都丢弃了，这个时候其实对系统并没有什么影响，但是连接到对应Follower上的客户端看到的数据就是stale的。<br>如果丢弃ReqA对应的Commit请求之后就撤销故障场景，ReqB对应的Commit请求正常执行会是什么情况呢？对应的逻辑在<strong>FollowerZooKeeperServer.commit</strong>中：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span> 收到Leader发送的Leader.COMMIT请求之后，会调用这个方法</div><div class="line">public void commit(long zxid) &#123;</div><div class="line">    <span class="regexp">//</span> FollowerZooKeeperServer.logRequest中会添加条目到pendingTxns中</div><div class="line">    <span class="regexp">//</span> 这个field保存了所有调用了syncProcessor.processRequest，但是没有收到</div><div class="line">    <span class="regexp">//</span> Commit请求的Request</div><div class="line">    <span class="keyword">if</span> (pendingTxns.size() == <span class="number">0</span>) &#123;</div><div class="line">        LOG.warn(<span class="string">"Committing "</span> + Long.toHexString(zxid)</div><div class="line">                + <span class="string">" without seeing txn"</span>);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    <span class="regexp">//</span> 如果收到的Commit请求中的zxid和pendingTxns中第一个请求的zxid是不一样的</div><div class="line">    <span class="regexp">//</span> 打印Error级别的日志并退出java进程</div><div class="line">    <span class="regexp">//</span> 在我们的模拟情况中，pendingTxns中第一个请求是ReqA</div><div class="line">    <span class="regexp">//</span> 所以当ReqB对应的Commit请求被Follower收到时，会进入到这个逻辑</div><div class="line">    long firstElementZxid = pendingTxns.element().zxid;</div><div class="line">    <span class="keyword">if</span> (firstElementZxid != zxid) &#123;</div><div class="line">        LOG.error(<span class="string">"Committing zxid 0x"</span> + Long.toHexString(zxid)</div><div class="line">                + <span class="string">" but next pending txn 0x"</span></div><div class="line">                + Long.toHexString(firstElementZxid));</div><div class="line">        System.<span class="keyword">exit</span>(<span class="number">12</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="regexp">//</span> 如果是匹配的，就从pendingTxns中移除这个请求</div><div class="line">    <span class="regexp">//</span> 并执行commitProcessor.commit</div><div class="line">    Request request = pendingTxns.remove();</div><div class="line">    commitProcessor.commit(request);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>是的，对应的<strong>Follower</strong>进程退出了。</p>
<h2 id="问题C"><a href="#问题C" class="headerlink" title="问题C"></a>问题C</h2><blockquote>
<p>扩容的时候加了个节点，这时候新的写入会不会同步到这个新节点呢？</p>
</blockquote>
<p>会的。虽然这时候<strong>Leader</strong>的<strong>conf/zoo.cfg</strong>里面还没有新加入节点的信息，但是<strong>Leader</strong>会为这个节点创建相应的<strong>LearnerHandler</strong>，对应的逻辑在<strong>Leader$LearnerCnxAcceptor.run</strong>中：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Socket s = ss.accept();</div><div class="line"><span class="comment">// start with the initLimit, once the ack is processed</span></div><div class="line"><span class="comment">// in LearnerHandler switch to the syncLimit</span></div><div class="line">s.setSoTimeout(self.tickTime * self.initLimit);</div><div class="line">s.setTcpNoDelay(nodelay);</div><div class="line">LearnerHandler fh = <span class="keyword">new</span> <span class="type">LearnerHandler</span>(s, Leader.<span class="built_in">this</span>);</div><div class="line">fh.start();</div></pre></td></tr></table></figure></p>
<p>新加入的节点也会经历如下的阶段：<br><a href="https://orimyicvd.bkt.clouddn.com/zk-node.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/zk-node.png"></a><br>上图中的步骤是在<strong>Learner.registerWithLeader</strong>和<strong>Learner.syncWithLeader</strong>中完成的，也是新加入节点从<strong>Leader</strong>中同步数据的步骤。再看看<strong>Leader</strong>是如何把增量的数据同步到<strong>Follower</strong>的。<br><strong>Leader</strong>向<strong>Follower</strong>发送请求的方法<strong>Leader.sendPacket</strong>实现如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">void</span> <span class="selector-tag">sendPacket</span>(QuorumPacket qp) &#123;</div><div class="line">    <span class="selector-tag">synchronized</span> (forwardingFollowers) &#123;</div><div class="line">        <span class="selector-tag">for</span> (LearnerHandler <span class="attribute">f </span>: forwardingFollowers) &#123;</div><div class="line">            <span class="selector-tag">f</span><span class="selector-class">.queuePacket</span>(qp);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>新加入节点的<strong>LearnerHandler</strong>是在<strong>LearnerHandler.run</strong>中通过调用<strong>Leader.startForwarding</strong>加入到<strong>Leader.forwardingFollowers</strong>中的，加入之后<strong>Leader</strong>就会开始同步数据到新的节点了。<br>那么，在计算<strong>QuorumVerifier.containsQuorum</strong>的时候，会涉及到新加入的节点么？<br>答案是，某种程度上，会。<br>验证<strong>Ping</strong>或者<strong>Proposal</strong>是否达到大多数的逻辑是在<strong>QuorumPeer.quorumConfig</strong>中实现的。<br><strong>QuorumPeer.quorumConfig</strong>这个<strong>field</strong>对应的类型是<strong>QuorumVerifier</strong>这个接口，这个接口有两个实现：<strong>QuorumMaj</strong>和<strong>QuorumHierarchical</strong>，我们的部署比较简单，没有<strong>weight</strong>相关的配置，所以使用的实现都是<strong>QuorumMaj</strong>。<br><strong>QuorumMaj</strong>中有一个<strong>field</strong>叫<strong>half</strong>，标志着这个集群里面半数的值（对于<strong>3节点</strong>的集群，<strong>half</strong>为<strong>1</strong>；对于<strong>4节点</strong>的集群，<strong>half</strong>为<strong>2</strong>；依此类推）；对应的<strong>containsQuorum</strong>方法实现也非常简单粗暴：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> boolean containsQuorum(HashSet&lt;<span class="built_in">Long</span>&gt; <span class="keyword">set</span>)&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">set</span>.size() &gt; half);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于<strong>QuorumPeer.setQuorumVerifier</strong>只有在节点启动的时候才会被调用，所以<strong>QuorumMaj.half</strong>的值在节点启动之后就不会改变。<br>如果在一个<strong>3节点（zk0、zk1、zk2）</strong>的集群中，扩容一个新节点<strong>zk3</strong>。在没有启动集群原有<strong>3节点</strong>的情况下，<strong>Leader</strong>中的<strong>QuorumMaj.half</strong>会一直为<strong>1</strong>，只是这时候，<strong>containsQuorum</strong>方法的输入可能是一个大小为<strong>4</strong>的集合。<br>可以理解为<strong>Leader</strong>中判断<strong>Proposal</strong>是否达到大多数的标准是没有变化的，但是输入产生了变化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下描述中用&lt;strong&gt;zk&lt;/strong&gt;代指&lt;strong&gt;ZooKeeper&lt;/strong&gt;，源码解释均基于&lt;strong&gt;ZooKeeper 3.4.6&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1、背景&quot;&gt;&lt;a href=&quot;#1、背景&quot; class=&quot;he
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo添加百度统计流程</title>
    <link href="https://hackbuteers.github.io/2017/06/14/tongji/"/>
    <id>https://hackbuteers.github.io/2017/06/14/tongji/</id>
    <published>2017-06-14T06:58:36.000Z</published>
    <updated>2017-06-14T09:02:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>今天介绍一下<code>hexo</code>中如何使用统计插件，每天看到自己的博客访问量越来越高也是一种享受。</p>
<h2 id="2、正文"><a href="#2、正文" class="headerlink" title="2、正文"></a>2、正文</h2><ul>
<li>1、现在百度统计官网，注册一个账号，并且绑定好域名。</li>
<li>2、再复制hm.js后面的字符串如图：<br><a href="https://orimyicvd.bkt.clouddn.com/tongji.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/tongji.png"></a></li>
<li><p>3、编辑主题配置文件， 修改字段 baidu_analytics，值设置成你的百度统计脚本id。<br><a href="https://orimyicvd.bkt.clouddn.com/baiduId.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/baiduId.png"></a><br>至此完成。</p>
</li>
<li><p>4、刚开始我以为是我的网站上可以看到百度统计的结果。原本是要到百度统计官网去看。<br><a href="https://orimyicvd.bkt.clouddn.com/correct.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/correct.png"></a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;headerlink&quot; title=&quot;1、前言&quot;&gt;&lt;/a&gt;1、前言&lt;/h2&gt;&lt;p&gt;今天介绍一下&lt;code&gt;hexo&lt;/code&gt;中如何使用统计插件，每天看到自己的博客访问量越来越高也是一种享受。&lt;/p&gt;
&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Intellij IDEA 配置Tomcat远程调试</title>
    <link href="https://hackbuteers.github.io/2017/06/13/idea_debug/"/>
    <id>https://hackbuteers.github.io/2017/06/13/idea_debug/</id>
    <published>2017-06-13T12:36:32.000Z</published>
    <updated>2017-06-14T08:45:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>在服务器端开发过程中，由于服务器环境差异导致运行结果不符合预期。<br>所以就需要用到IDEA Debug 服务器代码，看起来貌似很高大上的事情。<br>今天就说说使用Intellij IDEA 配置Debug的方法。</p>
<h2 id="2、环境和要求"><a href="#2、环境和要求" class="headerlink" title="2、环境和要求"></a>2、环境和要求</h2><p>IDEA：Intellij IDEA 2017.1.1<br>Web服务端：Tomcat 7.0.42</p>
<h3 id="3、服务器Tomcat配置"><a href="#3、服务器Tomcat配置" class="headerlink" title="3、服务器Tomcat配置"></a>3、服务器Tomcat配置</h3><p>找到Tomcat的bin目录，编辑/bin/catalina.sh<br>添加如下命令行<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">CATALINA_OPTS</span>=<span class="string">"-Xdebug -Xrunjdwp:transport=dt_socket,address=60222,suspend=n,server=y"</span></div></pre></td></tr></table></figure></p>
<p><a href="https://orimyicvd.bkt.clouddn.com/tom" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/tom"></a></p>
<h3 id="4、客户端IDEA配置"><a href="#4、客户端IDEA配置" class="headerlink" title="4、客户端IDEA配置"></a>4、客户端IDEA配置</h3><p><a href="https://orimyicvd.bkt.clouddn.com/remote.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/remote.png"></a><br><a href="https://orimyicvd.bkt.clouddn.com/iedq.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/iedq.png"></a><br><a href="https://orimyicvd.bkt.clouddn.com/startUp.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/startUp.png"></a><br>tocat的bin路径下catalina.sh中添加的那行代码的端口号，必须要和下面的三个端口号一样，否则无法远程调试。<br><a href="https://orimyicvd.bkt.clouddn.com/debug.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/debug.png"></a><br>或者点击右上角的一个小图标按钮也是OK的，<br><a href="https://orimyicvd.bkt.clouddn.com/hits.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/hits.png"></a><br><a href="https://orimyicvd.bkt.clouddn.com/target.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/target.png"></a><br>（切记：远程tomcat 调试，必须要把对应的war包拷贝到webapps目录下，否则只是链接制定到某个工程下的target目录下，是无法远程调试的。）<br>提示：Connected to the target VM, address: ‘10.11.2.128:60222’, transport: ‘socket’，说明远程调试已经连接成功了。</p>
<p>如下命令可以查看对应端口占用情况<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lsof -<span class="selector-tag">i</span>:<span class="number">60222</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;headerlink&quot; title=&quot;1、前言&quot;&gt;&lt;/a&gt;1、前言&lt;/h2&gt;&lt;p&gt;在服务器端开发过程中，由于服务器环境差异导致运行结果不符合预期。&lt;br&gt;所以就需要用到IDEA Debug 服务器代码，看起
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux机器之间互相免登陆</title>
    <link href="https://hackbuteers.github.io/2017/06/08/hello-world/"/>
    <id>https://hackbuteers.github.io/2017/06/08/hello-world/</id>
    <published>2017-06-08T02:52:59.000Z</published>
    <updated>2017-06-13T12:30:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>A为某台Linux主机(机器Ip:10.19.17.28);<br>B为远程主机(机器Ip:10.11.8.25);<br>A和B的系统都是Linux，最终实现A主机免登陆到目标B主机。</p>
<h2 id="1、生成公钥和私钥"><a href="#1、生成公钥和私钥" class="headerlink" title="1、生成公钥和私钥"></a>1、生成公钥和私钥</h2><h3 id="在A机器上执行命令"><a href="#在A机器上执行命令" class="headerlink" title="在A机器上执行命令"></a>在A机器上执行命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa</div></pre></td></tr></table></figure>
<p>默认在 ~/.ssh目录生成两个文件：<br>id_rsa      ：私钥<br>id_rsa.pub  ：公钥</p>
<p>将公钥信息拷贝到目标B机器上面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ scp ~/.ssh/id_rsa.pub mapp@10.11.8.25:.ssh/id_rsa.pub (需要输入密码)</div></pre></td></tr></table></figure></p>
<h3 id="2、导入公钥到认证文件，更改权限-在B机器上执行的命令"><a href="#2、导入公钥到认证文件，更改权限-在B机器上执行的命令" class="headerlink" title="2、导入公钥到认证文件，更改权限(在B机器上执行的命令)"></a>2、导入公钥到认证文件，更改权限(在B机器上执行的命令)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ touch /mapp/.ssh/authorized_keys (如果已经存在这个文件, 跳过这条)</div><div class="line">$ chmod 600 ~/.ssh/authorized_keys  (<span class="comment"># 注意： 必须将~/.ssh/authorized_keys的权限改为600, 该文件用于保存ssh客户端生成的公钥，可以修改服务器的ssh服务端配置文件/etc/ssh/sshd_config来指定其他文件名）</span></div><div class="line">$ cat /mapp/.ssh/id_rsa.pub  &gt;&gt; /mapp/.ssh/authorized_keys (将id_rsa.pub的内容追加到 authorized_keys 中, 注意不要用 &gt; ，否则会清空原有的内容，使其他人无法使用原有的密钥登录)</div></pre></td></tr></table></figure>
<h3 id="3、回到A机器，执行命令，直接进行免登陆跳转"><a href="#3、回到A机器，执行命令，直接进行免登陆跳转" class="headerlink" title="3、回到A机器，执行命令，直接进行免登陆跳转"></a>3、回到A机器，执行命令，直接进行免登陆跳转</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh mapp@10.11.8.25 -p 10022</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;A为某台Linux主机(机器Ip:10.19.17.28);&lt;br&gt;B为远程主机(机器Ip:10.11.8.25);&lt;br&gt;A和B的系统都是Linux，最终实现A主机免登陆到目标B主机。&lt;/p&gt;
&lt;h2 id=&quot;1、生成公钥和私钥&quot;&gt;&lt;a href=&quot;#1、生成公钥和私钥&quot;
    
    </summary>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>笔记随想</title>
  <subtitle>dddddd</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hackbuteers.github.io/"/>
  <updated>2017-06-14T09:54:05.000Z</updated>
  <id>https://hackbuteers.github.io/</id>
  
  <author>
    <name>hackbuteer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ZooKeeper - Data Sync</title>
    <link href="https://hackbuteers.github.io/2017/06/14/ZK-Data-Sync/"/>
    <id>https://hackbuteers.github.io/2017/06/14/ZK-Data-Sync/</id>
    <published>2017-06-14T09:11:33.000Z</published>
    <updated>2017-06-14T09:54:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下描述中用<strong>zk</strong>代指<strong>ZooKeeper</strong>，源码解释均基于<strong>ZooKeeper 3.4.6</strong></p>
<h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><p>继上次的<strong>Session</strong>问题后，好学的小冷同学又认真地研究了下<strong>ZooKeeper Cluster</strong>的原理，问了我下面5个问题：</p>
<blockquote>
<ul>
<li><strong>ZooKeeper</strong>集群在发生<strong>Leader</strong>切换的时候，所有的<strong>Follower</strong>会选择新的<strong>Leader</strong>进行全量的数据同步吗？</li>
<li>如果一次写入，由于丢包，导致某条日志没有写入，会怎么样呢？</li>
<li>扩容的时候加了个节点，这时候新的写入会不会同步到这个新节点呢？</li>
<li><strong>Follower</strong>会主动向<strong>Leader</strong>发<strong>ping</strong>包么？</li>
<li>集群在选举的时候，四字命令都会返回<strong>This ZooKeeper instance is not currently serving requests</strong>，什么时候会变回正常可服务状态？</li>
</ul>
</blockquote>
<p>这几个问题我都不太确定，于是，踏上了新一轮的<strong>啃码之旅</strong>。</p>
<h2 id="问题A"><a href="#问题A" class="headerlink" title="问题A"></a>问题A</h2><blockquote>
<p><strong>ZooKeeper</strong>集群在发生<strong>Leader</strong>切换的时候，所有的<strong>Follower</strong>会选择新的<strong>Leader</strong>进行全量的数据同步吗？</p>
</blockquote>
<p>这篇帖子里面的解释是我比较认同：</p>
<blockquote>
<p>1、SNAP-全量同步<br>条件：peerLastZxid<mincommittedlog 说明：证明二者数据差异太大，follower数据过于陈旧，leader发送快照snap指令给follower全量同步数据，即leader将所有数据全量同步到follower="" 2、diff-增量同步="" 条件：mincommittedlog<="peerLastZxid<=maxCommittedLog" 说明：证明二者数据差异不大，follower上有一些leader上已经提交的提议proposal未同步，此时需要增量提交这些提议即可="" 3、trunc-仅回滚同步="" 条件：peerlastzxid="">minCommittedLog<br>说明：证明follower上有些提议proposal并未在leader上提交，follower需要回滚到zxid为minCommittedLog对应的事务操作<br>4、TRUNC+DIFF-回滚+增量同步<br>条件：minCommittedLog&lt;=peerLastZxid&lt;=maxCommittedLog且特殊场景leader a已经将事务truncA提交到本地事务日志中，但没有成功发起proposal协议进行投票就宕机了；然后集群中剔除原leader a重新选举出新leader b，又提交了若干新的提议proposal，然后原leader a重新服务又加入到集群中，不管是否被选举为新leader。<br>说明：此时a,b都有一些对方未提交的事务，若b是leader, a需要先回滚truncA然后增量同步新leader a上的数据</mincommittedlog></p>
</blockquote>
<p>对应的代码在<strong>LearnerHandler.run</strong>中：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// packetToSend默认为Leader.SNAP</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    rl.<span class="built_in">lock</span>();</div><div class="line">    final long maxCommittedLog = <span class="built_in">leader</span>.zk.getZKDatabase().getmaxCommittedLog();</div><div class="line">    final long minCommittedLog = <span class="built_in">leader</span>.zk.getZKDatabase().getminCommittedLog();</div><div class="line">    <span class="built_in">LOG</span>.info(<span class="string">"Synchronizing with Follower sid: "</span> + sid</div><div class="line">            +<span class="string">" maxCommittedLog=0x"</span>+Long.toHexString(maxCommittedLog)</div><div class="line">            +<span class="string">" minCommittedLog=0x"</span>+Long.toHexString(minCommittedLog)</div><div class="line">            +<span class="string">" peerLastZxid=0x"</span>+Long.toHexString(peerLastZxid));</div><div class="line"></div><div class="line">    <span class="comment">// ZKDatabase.committedLog是仅存在于内存中的结构，虽然Follower或者Leader退出时，</span></div><div class="line">    <span class="comment">// 会调用ZKDatabase.clear清空内存中的数据，但是FastLeaderElection.getInitLastLoggedZxid</span></div><div class="line">    <span class="comment">// 最终会调用ZKDatabase.loadDataBase重新加载数据到ZKDatabase.committedLog等内存结构中</span></div><div class="line">    <span class="comment">// 当然，ZKDatabase.loadDataBase是把日志文件中的内容加载加这个结构中</span></div><div class="line">    <span class="comment">// 如果加载之前，对应的zk节点刚好是新生成的snapshot，就会导致ZKDatabase.committedLog为空</span></div><div class="line">    LinkedList&lt;Proposal&gt; proposals = <span class="built_in">leader</span>.zk.getZKDatabase().getCommittedLog();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (proposals.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">LOG</span>.debug(<span class="string">"proposal size is &#123;&#125;"</span>, proposals.<span class="built_in">size</span>());</div><div class="line">        <span class="keyword">if</span> ((maxCommittedLog &gt;= peerLastZxid)</div><div class="line">                &amp;&amp; (minCommittedLog &lt;= peerLastZxid)) &#123;</div><div class="line">            <span class="comment">// 如果Follower的zxid在[minCommittedLog, maxCommittedLog]，说明可能可以通过重新应用Follower上没有的事务日志来恢复数据</span></div><div class="line">            <span class="built_in">LOG</span>.debug(<span class="string">"Sending proposals to follower"</span>);</div><div class="line"></div><div class="line">            <span class="comment">// as we look through proposals, this variable keeps track of previous</span></div><div class="line">            <span class="comment">// proposal Id.</span></div><div class="line">            long prevProposalZxid = minCommittedLog;</div><div class="line"></div><div class="line">            <span class="comment">// Keep track of whether we are about to send the first packet.</span></div><div class="line">            <span class="comment">// Before sending the first packet, we have to tell the learner</span></div><div class="line">            <span class="comment">// whether to expect a trunc or a diff</span></div><div class="line">            boolean firstPacket=<span class="literal">true</span>;</div><div class="line"></div><div class="line">            <span class="comment">// If we are here, we can use committedLog to sync with</span></div><div class="line">            <span class="comment">// follower. Then we only need to decide whether to</span></div><div class="line">            <span class="comment">// send trunc or not</span></div><div class="line">            packetToSend = <span class="built_in">Leader</span>.DIFF;</div><div class="line">            zxidToSend = maxCommittedLog;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (Proposal propose: proposals) &#123;</div><div class="line">                <span class="comment">// 遍历ZKDatabase.committedLog中的事务日志，跳过那些已经在Follower上应用过的日志</span></div><div class="line">                <span class="comment">// skip the proposals the peer already has</span></div><div class="line">                <span class="keyword">if</span> (propose.packet.getZxid() &lt;= peerLastZxid) &#123;</div><div class="line">                    prevProposalZxid = propose.packet.getZxid();</div><div class="line">                    continue;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// If we are sending the first packet, figure out whether to trunc</span></div><div class="line">                    <span class="comment">// in case the follower has some proposals that the leader doesn't</span></div><div class="line">                    <span class="keyword">if</span> (firstPacket) &#123;</div><div class="line">                        firstPacket = <span class="literal">false</span>;</div><div class="line">                        <span class="comment">// Does the peer have some proposals that the leader hasn't seen yet</span></div><div class="line">                        <span class="keyword">if</span> (prevProposalZxid &lt; peerLastZxid) &#123;</div><div class="line">                            <span class="comment">// send a trunc message before sending the diff</span></div><div class="line">                            <span class="comment">// 如果出现这种情况，我们需要先在Follower上应用Leader.TRUNC，让其回滚到prevProposalZxid的位置</span></div><div class="line">                            packetToSend = <span class="built_in">Leader</span>.TRUNC;</div><div class="line">                            zxidToSend = prevProposalZxid;</div><div class="line">                            updates = zxidToSend;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 下面这几行语句是针对Follower上没有的事务日志构造出PROPOSAL和COMMIT请求，放到队列中</span></div><div class="line">                    <span class="comment">// 可以注意到，这个时候LearnerHandler的发送线程是还没有启动的，所以对应的FOLLOWER肯定是先响应Leader.DIFF或者Leader.TRUNC请求的</span></div><div class="line">                    queuePacket(propose.packet);</div><div class="line">                    QuorumPacket qcommit = new QuorumPacket(<span class="built_in">Leader</span>.COMMIT, propose.packet.getZxid(),</div><div class="line">                            null, null);</div><div class="line">                    queuePacket(qcommit);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (peerLastZxid &gt; maxCommittedLog) &#123;</div><div class="line">            <span class="comment">// 如果Follower的zxid比当前的Leader还要大，发送Leader.TRUNC让Follower的事务日志回滚到当前Leader的maxCommittedLog</span></div><div class="line">            <span class="comment">// 和Leader.SNAP一样，Leader.TRUNC会导致对应的Follower调用ZKDatabase.loadDataBase重新加载数据到内存中</span></div><div class="line">            <span class="built_in">LOG</span>.debug(<span class="string">"Sending TRUNC to follower zxidToSend=0x&#123;&#125; updates=0x&#123;&#125;"</span>,</div><div class="line">                    Long.toHexString(maxCommittedLog),</div><div class="line">                    Long.toHexString(updates));</div><div class="line"></div><div class="line">            packetToSend = <span class="built_in">Leader</span>.TRUNC;</div><div class="line">            zxidToSend = maxCommittedLog;</div><div class="line">            updates = zxidToSend;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 进入这块代码的条件是peerLastZxid&lt;minCommittedLog，使用默认的packetToSend：Leader.SNAP</span></div><div class="line">            <span class="comment">// 这个条件有一个case：在zk集群中加入一个新的节点，这时候如果Leader        的事务日志中有内容，就会进入这个情况</span></div><div class="line">            <span class="built_in">LOG</span>.warn(<span class="string">"Unhandled proposal scenario"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (peerLastZxid == <span class="built_in">leader</span>.zk.getZKDatabase().getDataTreeLastProcessedZxid()) &#123;</div><div class="line">        <span class="comment">// 如果ZKDatabase.committedLog为空，而且对应的Follower和当前Leader内存中的数据是一致的，只发送一个Leader.DIFF的请求</span></div><div class="line">        <span class="comment">// 而不进行数据的同步，甚至也没有对应的PROPOSAL/COMMIT请求</span></div><div class="line">        <span class="comment">// The leader may recently take a snapshot, so the committedLog</span></div><div class="line">        <span class="comment">// is empty. We don't need to send snapshot if the follow</span></div><div class="line">        <span class="comment">// is already sync with in-memory db.</span></div><div class="line">        <span class="built_in">LOG</span>.debug(<span class="string">"committedLog is empty but leader and follower "</span></div><div class="line">                + <span class="string">"are in sync, zxid=0x&#123;&#125;"</span>,</div><div class="line">                Long.toHexString(peerLastZxid));</div><div class="line">        packetToSend = <span class="built_in">Leader</span>.DIFF;</div><div class="line">        zxidToSend = peerLastZxid;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 如果ZKDatabase.committedLog为空，但是对应的Follower和当前Leader内存中的数据不一致</span></div><div class="line">        <span class="comment">// 这时候会使用默认的packetToSend：Leader.SNAP</span></div><div class="line">        <span class="comment">// just let the state transfer happen</span></div><div class="line">        <span class="built_in">LOG</span>.debug(<span class="string">"proposals is empty"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">LOG</span>.info(<span class="string">"Sending "</span> + <span class="built_in">Leader</span>.getPacketType(packetToSend));</div><div class="line">    leaderLastZxid = <span class="built_in">leader</span>.startForwarding(this, updates);</div><div class="line"></div><div class="line">&#125; finally &#123;</div><div class="line">    rl.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下描述中用&lt;strong&gt;zk&lt;/strong&gt;代指&lt;strong&gt;ZooKeeper&lt;/strong&gt;，源码解释均基于&lt;strong&gt;ZooKeeper 3.4.6&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1、背景&quot;&gt;&lt;a href=&quot;#1、背景&quot; class=&quot;he
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo添加百度统计流程</title>
    <link href="https://hackbuteers.github.io/2017/06/14/tongji/"/>
    <id>https://hackbuteers.github.io/2017/06/14/tongji/</id>
    <published>2017-06-14T06:58:36.000Z</published>
    <updated>2017-06-14T09:02:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>今天介绍一下<code>hexo</code>中如何使用统计插件，每天看到自己的博客访问量越来越高也是一种享受。</p>
<h2 id="2、正文"><a href="#2、正文" class="headerlink" title="2、正文"></a>2、正文</h2><ul>
<li>1、现在百度统计官网，注册一个账号，并且绑定好域名。</li>
<li>2、再复制hm.js后面的字符串如图：<br><a href="https://orimyicvd.bkt.clouddn.com/tongji.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/tongji.png"></a></li>
<li><p>3、编辑主题配置文件， 修改字段 baidu_analytics，值设置成你的百度统计脚本id。<br><a href="https://orimyicvd.bkt.clouddn.com/baiduId.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/baiduId.png"></a><br>至此完成。</p>
</li>
<li><p>4、刚开始我以为是我的网站上可以看到百度统计的结果。原本是要到百度统计官网去看。<br><a href="https://orimyicvd.bkt.clouddn.com/correct.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/correct.png"></a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;headerlink&quot; title=&quot;1、前言&quot;&gt;&lt;/a&gt;1、前言&lt;/h2&gt;&lt;p&gt;今天介绍一下&lt;code&gt;hexo&lt;/code&gt;中如何使用统计插件，每天看到自己的博客访问量越来越高也是一种享受。&lt;/p&gt;
&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Intellij IDEA 配置Tomcat远程调试</title>
    <link href="https://hackbuteers.github.io/2017/06/13/idea_debug/"/>
    <id>https://hackbuteers.github.io/2017/06/13/idea_debug/</id>
    <published>2017-06-13T12:36:32.000Z</published>
    <updated>2017-06-14T08:45:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>在服务器端开发过程中，由于服务器环境差异导致运行结果不符合预期。<br>所以就需要用到IDEA Debug 服务器代码，看起来貌似很高大上的事情。<br>今天就说说使用Intellij IDEA 配置Debug的方法。</p>
<h2 id="2、环境和要求"><a href="#2、环境和要求" class="headerlink" title="2、环境和要求"></a>2、环境和要求</h2><p>IDEA：Intellij IDEA 2017.1.1<br>Web服务端：Tomcat 7.0.42</p>
<h3 id="3、服务器Tomcat配置"><a href="#3、服务器Tomcat配置" class="headerlink" title="3、服务器Tomcat配置"></a>3、服务器Tomcat配置</h3><p>找到Tomcat的bin目录，编辑/bin/catalina.sh<br>添加如下命令行<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">CATALINA_OPTS</span>=<span class="string">"-Xdebug -Xrunjdwp:transport=dt_socket,address=60222,suspend=n,server=y"</span></div></pre></td></tr></table></figure></p>
<p><a href="https://orimyicvd.bkt.clouddn.com/tom" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/tom"></a></p>
<h3 id="4、客户端IDEA配置"><a href="#4、客户端IDEA配置" class="headerlink" title="4、客户端IDEA配置"></a>4、客户端IDEA配置</h3><p><a href="https://orimyicvd.bkt.clouddn.com/remote.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/remote.png"></a><br><a href="https://orimyicvd.bkt.clouddn.com/iedq.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/iedq.png"></a><br><a href="https://orimyicvd.bkt.clouddn.com/startUp.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/startUp.png"></a><br>tocat的bin路径下catalina.sh中添加的那行代码的端口号，必须要和下面的三个端口号一样，否则无法远程调试。<br><a href="https://orimyicvd.bkt.clouddn.com/debug.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/debug.png"></a><br>或者点击右上角的一个小图标按钮也是OK的，<br><a href="https://orimyicvd.bkt.clouddn.com/hits.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/hits.png"></a><br><a href="https://orimyicvd.bkt.clouddn.com/target.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/target.png"></a><br>（切记：远程tomcat 调试，必须要把对应的war包拷贝到webapps目录下，否则只是链接制定到某个工程下的target目录下，是无法远程调试的。）<br>提示：Connected to the target VM, address: ‘10.11.2.128:60222’, transport: ‘socket’，说明远程调试已经连接成功了。</p>
<p>如下命令可以查看对应端口占用情况<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lsof -<span class="selector-tag">i</span>:<span class="number">60222</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;headerlink&quot; title=&quot;1、前言&quot;&gt;&lt;/a&gt;1、前言&lt;/h2&gt;&lt;p&gt;在服务器端开发过程中，由于服务器环境差异导致运行结果不符合预期。&lt;br&gt;所以就需要用到IDEA Debug 服务器代码，看起
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux机器之间互相免登陆</title>
    <link href="https://hackbuteers.github.io/2017/06/08/hello-world/"/>
    <id>https://hackbuteers.github.io/2017/06/08/hello-world/</id>
    <published>2017-06-08T02:52:59.000Z</published>
    <updated>2017-06-13T12:30:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>A为某台Linux主机(机器Ip:10.19.17.28);<br>B为远程主机(机器Ip:10.11.8.25);<br>A和B的系统都是Linux，最终实现A主机免登陆到目标B主机。</p>
<h2 id="1、生成公钥和私钥"><a href="#1、生成公钥和私钥" class="headerlink" title="1、生成公钥和私钥"></a>1、生成公钥和私钥</h2><h3 id="在A机器上执行命令"><a href="#在A机器上执行命令" class="headerlink" title="在A机器上执行命令"></a>在A机器上执行命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa</div></pre></td></tr></table></figure>
<p>默认在 ~/.ssh目录生成两个文件：<br>id_rsa      ：私钥<br>id_rsa.pub  ：公钥</p>
<p>将公钥信息拷贝到目标B机器上面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ scp ~/.ssh/id_rsa.pub mapp@10.11.8.25:.ssh/id_rsa.pub (需要输入密码)</div></pre></td></tr></table></figure></p>
<h3 id="2、导入公钥到认证文件，更改权限-在B机器上执行的命令"><a href="#2、导入公钥到认证文件，更改权限-在B机器上执行的命令" class="headerlink" title="2、导入公钥到认证文件，更改权限(在B机器上执行的命令)"></a>2、导入公钥到认证文件，更改权限(在B机器上执行的命令)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ touch /mapp/.ssh/authorized_keys (如果已经存在这个文件, 跳过这条)</div><div class="line">$ chmod 600 ~/.ssh/authorized_keys  (<span class="comment"># 注意： 必须将~/.ssh/authorized_keys的权限改为600, 该文件用于保存ssh客户端生成的公钥，可以修改服务器的ssh服务端配置文件/etc/ssh/sshd_config来指定其他文件名）</span></div><div class="line">$ cat /mapp/.ssh/id_rsa.pub  &gt;&gt; /mapp/.ssh/authorized_keys (将id_rsa.pub的内容追加到 authorized_keys 中, 注意不要用 &gt; ，否则会清空原有的内容，使其他人无法使用原有的密钥登录)</div></pre></td></tr></table></figure>
<h3 id="3、回到A机器，执行命令，直接进行免登陆跳转"><a href="#3、回到A机器，执行命令，直接进行免登陆跳转" class="headerlink" title="3、回到A机器，执行命令，直接进行免登陆跳转"></a>3、回到A机器，执行命令，直接进行免登陆跳转</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh mapp@10.11.8.25 -p 10022</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;A为某台Linux主机(机器Ip:10.19.17.28);&lt;br&gt;B为远程主机(机器Ip:10.11.8.25);&lt;br&gt;A和B的系统都是Linux，最终实现A主机免登陆到目标B主机。&lt;/p&gt;
&lt;h2 id=&quot;1、生成公钥和私钥&quot;&gt;&lt;a href=&quot;#1、生成公钥和私钥&quot;
    
    </summary>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>笔记随想</title>
  <subtitle>程序员上辈子都是折翼的天使</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hackbuteers.github.io/"/>
  <updated>2017-06-18T12:34:47.000Z</updated>
  <id>https://hackbuteers.github.io/</id>
  
  <author>
    <name>hackbuteer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Storm集群的搭建</title>
    <link href="https://hackbuteers.github.io/2017/06/18/Storm%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://hackbuteers.github.io/2017/06/18/Storm集群的搭建/</id>
    <published>2017-06-18T12:34:02.000Z</published>
    <updated>2017-06-18T12:34:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>安装Storm集群，需要依赖以下组件：</p>
<blockquote>
<p>Zookeeper<br>Python<br>Zeromq<br>Storm<br>JDK<br>JZMQ</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装Storm集群，需要依赖以下组件：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Zookeeper&lt;br&gt;Python&lt;br&gt;Zeromq&lt;br&gt;Storm&lt;br&gt;JDK&lt;br&gt;JZMQ&lt;/p&gt;
&lt;/blockquote&gt;

    
    </summary>
    
      <category term="ZooKeeper" scheme="https://hackbuteers.github.io/categories/ZooKeeper/"/>
    
    
      <category term="ZooKeeper" scheme="https://hackbuteers.github.io/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>Apache_Kafka入门（二）</title>
    <link href="https://hackbuteers.github.io/2017/06/18/Apache-Kafka2/"/>
    <id>https://hackbuteers.github.io/2017/06/18/Apache-Kafka2/</id>
    <published>2017-06-18T12:27:35.000Z</published>
    <updated>2017-06-18T12:56:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Apache-Kafka入门（二）"><a href="#Apache-Kafka入门（二）" class="headerlink" title="Apache_Kafka入门（二）"></a>Apache_Kafka入门（二）</h2><blockquote>
<p>前面我们搭建了3个broker的kafka集群 本篇我们介绍一下kafka的一些配置以及java代码，从中学习和理解kafka的一些设计。</p>
</blockquote>
<h2 id="一、Producer和Consumer主要配置"><a href="#一、Producer和Consumer主要配置" class="headerlink" title="一、Producer和Consumer主要配置"></a>一、Producer和Consumer主要配置</h2><p>我们先来学习一下<strong>kafka</strong>关于<strong>producer</strong>和<strong>consumer</strong>的一些配置，通过配置信息对<strong>producer</strong>和<strong>consumer</strong>有个大体了解，同时也是在此做个记录，方便日后使用时查阅。</p>
<ul>
<li><p><strong>Producer</strong>主要配置：<a href="http://kafka.apache.org/documentation.html#producerconfigs" target="_blank" rel="external">官方文档</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 用于建立与kafka集群的连接，这个list仅仅影响用于初始化的hosts，来发现全部的servers。</span></div><div class="line"><span class="comment">##格式：host1:port1,host2:port2,…，数量尽量不止一个，以防其中一个down了</span></div><div class="line">bootstrap.servers=192.168.127.10:9092,192.168.127.11:9092,192.168.127.12:9092</div><div class="line"></div><div class="line"><span class="comment"># Producer用于压缩数据的压缩类型，取值：none, gzip, snappy, or lz4</span></div><div class="line">compression.type=none</div><div class="line"></div><div class="line"><span class="comment"># 消息序列化类，默认为kafka.serializer.DefaultEncoder，将消息实体转化为byte[]</span></div><div class="line">serializer.class=kafka.serializer.StringEncoder</div><div class="line"></div><div class="line"><span class="comment"># producer接收消息ack的时机，默认为0</span></div><div class="line"><span class="comment"># 0:producer不会等待确认，直接添加到socket等待发送；</span></div><div class="line"><span class="comment"># 1:这意味着至少要等待leader已经成功将数据写入本地log，但是并没有等待所有follower是否成功写入。这种情况下，如果follower没有成功备份数据，而此时leader又挂掉，则消息会丢失。</span></div><div class="line"><span class="comment"># all:这意味着leader需要等待所有备份都成功写入日志，这种策略会保证只要有一个备份存活就不会丢失数据。这是最强的保证。</span></div><div class="line">acks=0</div><div class="line"></div><div class="line"><span class="comment"># Producer可以用来缓存数据的内存大小。</span></div><div class="line"><span class="comment">##如果数据产生速度大于向broker发送的速度，producer会阻塞max.block.ms，超时则抛出异常</span></div><div class="line">buffer.memory=</div><div class="line"></div><div class="line"><span class="comment"># Producer默认会把两次发送时间间隔内收集到的所有Requests进行一次聚合然后再发送，以此提高吞吐量，而linger.ms则更进一步，这个参数为每次发送增加一些delay，以此来聚合更多的Message。</span></div><div class="line">linger.ms=</div><div class="line"></div><div class="line"><span class="comment"># 请求的最大字节数。这也是对最大消息大小的有效限制。</span></div><div class="line"><span class="comment"># 注意：server具有自己对消息大小的限制，这些大小和这个设置不同。此项设置将会限制producer每次批量发送请求的数目，以防发出巨量的请求。</span></div><div class="line">max.request.size=</div><div class="line"></div><div class="line"><span class="comment"># TCP的接收缓存 SO_RCVBUF 空间大小，用于读取数据</span></div><div class="line">receive.buffer.bytes=</div><div class="line"></div><div class="line"><span class="comment"># client等待请求响应的最大时间,如果在这个时间内没有收到响应，客户端将重发请求，超过重试次数发送失败</span></div><div class="line">request.timeout.ms=</div><div class="line"></div><div class="line"><span class="comment"># TCP的发送缓存 SO_SNDBUF 空间大小，用于发送数据</span></div><div class="line">send.buffer.bytes=</div><div class="line"></div><div class="line"><span class="comment"># 指定server等待来自followers的确认的最大时间，根据acks的设置，超时则返回error</span></div><div class="line">timeout.ms=</div><div class="line"></div><div class="line"><span class="comment"># 在block前一个connection上允许最大未确认的requests数量。</span></div><div class="line"><span class="comment"># 当设为1时，即是消息保证有序模式，注意：这里的消息保证有序是指对于单个Partition的消息有顺序，因此若要保证全局消息有序，可以只使用一个Partition，当然也会降低性能</span></div><div class="line">max.in.flight.requests.per.connection=</div><div class="line"></div><div class="line"><span class="comment"># 在第一次将数据发送到某topic时，需先fetch该topic的metadata，得知哪些服务器持有该topic的partition，该值为最长获取metadata时间</span></div><div class="line">metadata.fetch.timeout.ms=</div><div class="line"></div><div class="line"><span class="comment"># 连接失败时，当我们重新连接时的等待时间</span></div><div class="line">reconnect.backoff.ms=</div><div class="line"></div><div class="line"><span class="comment"># 在重试发送失败的request前的等待时间，防止若目的Broker完全挂掉的情况下Producer一直陷入死循环发送，折中的方法</span></div><div class="line">retry.backoff.ms=</div><div class="line"></div><div class="line"><span class="comment"># metrics系统维护可配置的样本数量，在一个可修正的window size</span></div><div class="line">metrics.sample.window.ms=30000</div><div class="line"></div><div class="line"><span class="comment"># 用于维护metrics的样本数</span></div><div class="line">metrics.num.samples=2</div><div class="line"></div><div class="line"><span class="comment"># 类的列表，用于衡量指标。实现MetricReporter接口</span></div><div class="line">metric.reporters=[]</div><div class="line"></div><div class="line"><span class="comment"># 强制刷新metadata的周期，即使leader没有变化</span></div><div class="line">metadata.max.age.ms=300000</div><div class="line"></div><div class="line"><span class="comment"># 与broker会话协议，取值：LAINTEXT, SSL, SASL_PLAINTEXT, SASL_SSL</span></div><div class="line">security.protocol=PLAINTEXT</div><div class="line"></div><div class="line"><span class="comment"># 分区类，实现Partitioner接口</span></div><div class="line">partitioner.class=class org.apache.kafka.clients.producer.internals.DefaultPartitioner</div><div class="line"></div><div class="line"><span class="comment"># 控制block的时长，当buffer空间不够或者metadata丢失时产生block</span></div><div class="line">max.block.ms=60000</div><div class="line"></div><div class="line"><span class="comment"># 关闭达到该时间的空闲连接</span></div><div class="line">connections.max.idle.ms=540000</div><div class="line"></div><div class="line"><span class="comment"># 当向server发出请求时，这个字符串会发送给server，目的是能够追踪请求源</span></div><div class="line">client.id=<span class="string">""</span></div><div class="line"></div><div class="line"><span class="comment"># 发生错误时，重传次数。当开启重传时，需要将`max.in.flight.requests.per.connection`设置为1，否则可能导致失序</span></div><div class="line">retries=0</div><div class="line"></div><div class="line"><span class="comment"># key 序列化方式，类型为class，需实现Serializer interface</span></div><div class="line">key.serializer=</div><div class="line"></div><div class="line"><span class="comment"># value 序列化方式，类型为class，需实现Serializer interface</span></div><div class="line">value.serializer=</div></pre></td></tr></table></figure>
</li>
<li><p><em>Consumer</em>主要配置：<a href="http://kafka.apache.org/documentation.html#newconsumerconfigs" target="_blank" rel="external">官方文档</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 用于建立与kafka集群的连接，这个list仅仅影响用于初始化的hosts，来发现全部的servers。</span></div><div class="line">bootstrap.servers=</div><div class="line"></div><div class="line"><span class="comment"># 用来唯一标识consumer进程所在组的字符串</span></div><div class="line">group.id=</div><div class="line"></div><div class="line"><span class="comment"># 单次拉取的最大消息条数</span></div><div class="line">max.poll.records=</div><div class="line"></div><div class="line"><span class="comment"># consumer失效时间，当长时间未收到心跳，并且大于这个时间，broker会将这个consumer从group中移除</span></div><div class="line">session.timeout.ms</div><div class="line"></div><div class="line"><span class="comment"># 心跳间隔，需低于session.timeout.ms时间，建议不高于其1/3</span></div><div class="line">heartbeat.interval.ms</div><div class="line"></div><div class="line"><span class="comment"># 如果设为true，consumer的offset将在后台定期自动提交</span></div><div class="line">enable.auto.commit</div><div class="line"></div><div class="line"><span class="comment"># 当enable.auto.commit设为true时，定期提交的时间间隔(ms)</span></div><div class="line">auto.commit.interval.ms</div><div class="line"></div><div class="line"><span class="comment"># 分区策略，取值为range或roundrobin</span></div><div class="line">partition.assignment.strategy</div><div class="line"></div><div class="line"><span class="comment"># 自动重置offset，取值earliest、latest、none</span></div><div class="line"><span class="comment"># earliest将offset设置为开始位置</span></div><div class="line"><span class="comment"># latest将offset设置为开始位置</span></div><div class="line">auto.offset.reset</div><div class="line"></div><div class="line"><span class="comment"># 每次最小拉取的消息大小（byte）。Consumer会等待消息积累到一定尺寸后进行批量拉取。默认为1，代表有一条就拉一条</span></div><div class="line">fetch.min.bytes</div><div class="line"></div><div class="line"><span class="comment"># 拉取消息的最大值</span></div><div class="line">fetch.max.bytes</div><div class="line"></div><div class="line"><span class="comment"># 当消息没有积累到fetch.min.bytes值的最大等待时间</span></div><div class="line">fetch.max.wait.ms</div><div class="line"></div><div class="line"><span class="comment"># 元数据刷新时间(无任何改变的情况下)</span></div><div class="line">metadata.max.age.ms</div><div class="line"></div><div class="line"><span class="comment"># 每次从单个分区中拉取的消息最大尺寸（byte），默认为1M</span></div><div class="line">max.partition.fetch.bytes</div><div class="line"></div><div class="line"><span class="comment"># tcp发送buffer数据的大小，如果值为-1，则为os默认值</span></div><div class="line">send.buffer.bytes</div><div class="line"></div><div class="line"><span class="comment"># tcp读取buffer数据的大小，如果值为-1，则为os默认值</span></div><div class="line">receive.buffer.bytes</div><div class="line"></div><div class="line"><span class="comment"># 客户端id</span></div><div class="line">client.id</div><div class="line"></div><div class="line"><span class="comment"># 连接时间间隔</span></div><div class="line">reconnect.backoff.ms</div><div class="line"></div><div class="line"><span class="comment"># 连接失败，重连时间间隔</span></div><div class="line">retry.backoff.ms</div><div class="line"></div><div class="line"><span class="comment"># 是否开启CRC32校验，默认为开启</span></div><div class="line">check.crcs</div><div class="line"></div><div class="line"><span class="comment"># 指定key的反序列化方式</span></div><div class="line">key.deserializer</div><div class="line"></div><div class="line"><span class="comment"># 指定value的反序列化方式</span></div><div class="line">value.deserializer</div><div class="line"></div><div class="line"><span class="comment"># 关闭连接的最大空闲时间，默认为540000ms</span></div><div class="line">connections.max.idle.ms</div><div class="line"></div><div class="line"><span class="comment"># 客户端等待响应最大时间</span></div><div class="line">request.timeout.ms</div><div class="line"></div><div class="line"><span class="comment"># 拦截器列表，默认没有拦截器</span></div><div class="line">interceptor.classes</div><div class="line"></div><div class="line"><span class="comment"># 内部topics信息是否可访问，默认为true</span></div><div class="line">exclude.internal.topics</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二、通过JAVA代码进入对Kafka的学习"><a href="#二、通过JAVA代码进入对Kafka的学习" class="headerlink" title="二、通过JAVA代码进入对Kafka的学习"></a>二、通过JAVA代码进入对Kafka的学习</h2><ul>
<li>构建maven项目，引入依赖<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;0.10.2.1&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-1-producer-发布消息"><a href="#2-1-producer-发布消息" class="headerlink" title="2.1 producer 发布消息"></a>2.1 producer 发布消息</h3><ul>
<li>Producer JAVA代码<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">import org.apache.kafka.clients.producer.KafkaProducer;</div><div class="line">import org.apache.kafka.clients.producer.Producer;</div><div class="line">import org.apache.kafka.clients.producer.ProducerRecord;</div><div class="line">import org.apache.kafka.clients.producer.RecordMetadata;</div><div class="line">import org.slf4j.Logger;</div><div class="line">import org.slf4j.LoggerFactory;</div><div class="line">import java.util.Properties;</div><div class="line">import java.util.concurrent.Future;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by Gao on 2017/5/13.</div><div class="line"> */</div><div class="line">public class ProducerDemo &#123;</div><div class="line">    private Producer&lt;String,String&gt; producer;</div><div class="line">    private Logger logger= LoggerFactory.getLogger(ProducerDemo.class);</div><div class="line"></div><div class="line">    public <span class="function"><span class="title">ProducerDemo</span></span>() &#123;</div><div class="line">        //producer配置信息</div><div class="line">        Properties config=new Properties();</div><div class="line">        config.setProperty(<span class="string">"bootstrap.servers"</span>,<span class="string">"192.168.127.10:9092,192.168.127.11:9092,192.168.127.12:9092"</span>);</div><div class="line">        config.setProperty(<span class="string">"value.serializer"</span>,<span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</div><div class="line">        config.setProperty(<span class="string">"key.serializer"</span>,<span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</div><div class="line">        config.setProperty(<span class="string">"acks"</span>,<span class="string">"0"</span>);</div><div class="line">        producer=new KafkaProducer&lt;String, String&gt;(config);</div><div class="line">    &#125;</div><div class="line">	//这里我们并没有指定partit</div><div class="line">    public void send(String topicName,String message)&#123;</div><div class="line">        <span class="keyword">if</span>(topicName==null||message==null)&#123;</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        &#125;</div><div class="line">		//创建消息实体</div><div class="line">        ProducerRecord&lt;String,String&gt; record=new ProducerRecord&lt;String, String&gt;(topicName,message);</div><div class="line">        Future&lt;RecordMetadata&gt; future = producer.send(record);</div><div class="line">        System.out.println(<span class="string">"send message ["</span>+message+<span class="string">"] success"</span>);</div><div class="line">        producer.flush();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="function"><span class="title">close</span></span>()&#123;</div><div class="line">        <span class="keyword">if</span>(producer!=null)&#123;</div><div class="line">            producer.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int i = 1;</div><div class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</div><div class="line">            new ProducerDemo().send(<span class="string">"kafka_study"</span>, <span class="string">"hello"</span> + i++);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(600);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-1-1-写入方式"><a href="#2-1-1-写入方式" class="headerlink" title="2.1.1 写入方式"></a>2.1.1 写入方式</h3><blockquote>
<p>producer 采用 push 模式将消息发布到 broker，每条消息都被 append 到 patition 中，属于顺序写磁盘（顺序写磁盘效率比随机写内存要高，保障 kafka 吞吐率）。</p>
</blockquote>
<h3 id="2-1-2-消息路由"><a href="#2-1-2-消息路由" class="headerlink" title="2.1.2 消息路由"></a>2.1.2 消息路由</h3><p><strong>producer</strong>发送消息到<strong>broker</strong>时，会根据分区算法选择将其存储到哪一个<strong>partition</strong>。其路由机制为：</p>
<blockquote>
<ol>
<li>指定了 patition，则直接使用；</li>
<li>未指定 patition 但指定 key，通过对 key 的 value 进行hash 选出一个 patition，通过这样的方案，kafka能够确保相同key值的数据可以写入同一个partition</li>
<li>patition 和 key 都未指定，使用轮询选出一个 patition。</li>
</ol>
</blockquote>
<p>下面是一些<strong>kafka client</strong>对于分区的一些源码片段<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//创建消息实例</div><div class="line">public ProducerRecord(String topic, Integer partition, Long timestamp, K key, V value) &#123;</div><div class="line">    <span class="keyword">if</span> (topic == null)</div><div class="line">        throw new IllegalArgumentException(<span class="string">"Topic cannot be null."</span>);</div><div class="line">    <span class="keyword">if</span> (timestamp != null &amp;&amp; timestamp &lt; 0)</div><div class="line">        throw new IllegalArgumentException(</div><div class="line">                String.format(<span class="string">"Invalid timestamp: %d. Timestamp should always be non-negative or null."</span>, timestamp));</div><div class="line">    <span class="keyword">if</span> (partition != null &amp;&amp; partition &lt; 0)</div><div class="line">        throw new IllegalArgumentException(</div><div class="line">                String.format(<span class="string">"Invalid partition: %d. Partition number should always be non-negative or null."</span>, partition));</div><div class="line">    this.topic = topic;</div><div class="line">    this.partition = partition;</div><div class="line">    this.key = key;</div><div class="line">    this.value = value;</div><div class="line">    this.timestamp = timestamp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private int partition(ProducerRecord&lt;K, V&gt; record, byte[] serializedKey, byte[] serializedValue, Cluster cluster) &#123;</div><div class="line">    Integer partition = record.partition();</div><div class="line">	//如果partition不为null就直接使用，如果为null则进行相应计算</div><div class="line">    <span class="built_in">return</span> partition != null ?</div><div class="line">            partition :</div><div class="line">            partitioner.partition(</div><div class="line">                    record.topic(), record.key(), serializedKey, record.value(), serializedValue, cluster);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//计算写入的partition。</div><div class="line">public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) &#123;</div><div class="line">    List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</div><div class="line">    int numPartitions = partitions.size();</div><div class="line">	//如果key为null,轮询选出一个 patition</div><div class="line">    <span class="keyword">if</span> (keyBytes == null) &#123;</div><div class="line">        int nextValue = nextValue(topic);</div><div class="line">        List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</div><div class="line">        <span class="keyword">if</span> (availablePartitions.size() &gt; 0) &#123;</div><div class="line">            int part = Utils.toPositive(nextValue) % availablePartitions.size();</div><div class="line">            <span class="built_in">return</span> availablePartitions.get(part).partition();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            // no partitions are available, give a non-available partition</div><div class="line">            <span class="built_in">return</span> Utils.toPositive(nextValue) % numPartitions;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">		//KEY不为null则通过对key的keyBytes进行<span class="built_in">hash</span>计算出一个partition</div><div class="line">        // <span class="built_in">hash</span> the keyBytes to choose a partition</div><div class="line">        <span class="built_in">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-1-3-消息写入流程"><a href="#2-1-3-消息写入流程" class="headerlink" title="2.1.3 消息写入流程"></a>2.1.3 消息写入流程</h3><blockquote>
<p>1.producer 先从 zookeeper 的 “/brokers/…/state” 节点找到该 partition 的 leader<br>2.producer 将消息发送给该 leader<br>3.leader 将消息写入本地 log<br>4.followers 从 leader pull 消息，写入本地 log 后向 leader 发送 ACK<br>5.leader 收到所有 ISR (In-Sync Replicas) 中的 replica 的 ACK 后，增加 HW（high watermark，最后 commit 的 offset） 并向 producer 发送 ACK</p>
</blockquote>
<h2 id="2-2-broker-保存消息"><a href="#2-2-broker-保存消息" class="headerlink" title="2.2 broker 保存消息"></a>2.2 broker 保存消息</h2><h3 id="2-2-1-存储方式"><a href="#2-2-1-存储方式" class="headerlink" title="2.2.1 存储方式"></a>2.2.1 存储方式</h3><p>物理上把<strong>topic</strong>分成一个或多个<strong>patition</strong>（对应 server.properties 中的 num.partitions=3 配置），每个 patition 物理上对应一个文件夹（该文件夹存储该 patition 的所有消息和索引文件以及kafka的具体时间日志），单个broker和多个broker的partition略有区别：</p>
<ul>
<li>单个<strong>Broker</strong>： 　　创建一个partition为3，Replica为1，Topic名字为kafka_study的topic。我们得到的分布式在配置好的LOG文件夹中生成三个分别为：kafka_study-0、kafka_study-1、kafka_study-2的文件夹用来存储Partition下的信息的.index文件.log文件和.timeindex文件。</li>
<li>多个<strong>Broker</strong>： 　　创建一个partition为3，Replica为1，Topic名字为kafka_study的topic。我们在Broker0中对应的LOG文件夹中只是发现了kafka_study-0的文件夹，在其他Broker中分别发现了Partition的文件夹。如果Broker数大于Partition数，那么有Broker中没有对应的Partition；如果Broker小于Partition数，Broker中会存在多个Partition。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Apache-Kafka入门（二）&quot;&gt;&lt;a href=&quot;#Apache-Kafka入门（二）&quot; class=&quot;headerlink&quot; title=&quot;Apache_Kafka入门（二）&quot;&gt;&lt;/a&gt;Apache_Kafka入门（二）&lt;/h2&gt;&lt;blockquote&gt;

    
    </summary>
    
      <category term="Kafka" scheme="https://hackbuteers.github.io/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="https://hackbuteers.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Apache_Kafka入门（一）</title>
    <link href="https://hackbuteers.github.io/2017/06/18/Apache-Kafka1/"/>
    <id>https://hackbuteers.github.io/2017/06/18/Apache-Kafka1/</id>
    <published>2017-06-18T12:27:22.000Z</published>
    <updated>2017-06-18T12:49:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、kafka是什么？"><a href="#一、kafka是什么？" class="headerlink" title="一、kafka是什么？"></a>一、kafka是什么？</h2><p><strong>kafka</strong>是一个分布式的、可分区的、可复制的消息系统。它使用<strong>Scala</strong>编写，它以可水平扩展和高吞吐率而被广泛使用。</p>
<h2 id="二、产生背景"><a href="#二、产生背景" class="headerlink" title="二、产生背景"></a>二、产生背景</h2><p><strong>Kafka</strong>是一个消息系统，用作<strong>LinkedIn</strong>的活动流（<strong>Activity Stream</strong>）和运营数据处理管道（<strong>Pipeline</strong>）的基础。活动流数据是几乎所有站点在对其网站使用情况做报表时都要用到的数据中最常规的部分。活动数据包括页面访问量（Page View）、被查看内容方面的信息以及搜索情况等内容。这种数据通常的处理方式是先把各种活动以日志的形式写入某种文件，然后周期性地对这些文件进行统计分析。运营数据指的3是服务器的性能数据（CPU、IO使用率、请求时间、服务日志等等数据)。运营数据的统计方法种类繁多。</p>
<h2 id="三、基本架构图"><a href="#三、基本架构图" class="headerlink" title="三、基本架构图"></a>三、基本架构图</h2><p><a href="http://orimyicvd.bkt.clouddn.com/kafka1.png" data-fancybox="images" target="_blank" rel="external"><img src="http://orimyicvd.bkt.clouddn.com/kafka1.png"></a></p>
<h2 id="四、基本概念的解释"><a href="#四、基本概念的解释" class="headerlink" title="四、基本概念的解释"></a>四、基本概念的解释</h2><ul>
<li>1、Broker Kafka集群包含一个或多个服务器，这种服务器被称为broker。broker端不维护数据的消费状态，提升了性能。直接使用磁盘进行存储，线性读写，速度快：避免了数据在JVM内存和系统内存之间的复制，减少耗性能的创建对象和垃圾回收。</li>
<li>2、Producer 负责发布消息到Kafka broker</li>
<li>3、Consumer 消息消费者，向Kafka broker读取消息的客户端，consumer从broker拉取(pull)数据并进行处理。</li>
<li>4、Topic 每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</li>
<li>5、Partition Parition是物理上的概念，每个Topic包含一个或多个Partition.</li>
<li>6、Consumer Group 每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）</li>
</ul>
<h2 id="五、kafka集群环境搭建"><a href="#五、kafka集群环境搭建" class="headerlink" title="五、kafka集群环境搭建"></a>五、kafka集群环境搭建</h2><h3 id="1-Zookeeper集群搭建"><a href="#1-Zookeeper集群搭建" class="headerlink" title="1) Zookeeper集群搭建"></a>1) Zookeeper集群搭建</h3><blockquote>
<p>Kafka集群是把状态保存在Zookeeper中的，首先要搭建Zookeeper集群。 Zookeeper环境的搭建请参照《Storm集群的搭建》。需要注意的是zookeeper需要java环境，所以记得先安装JDK。</p>
</blockquote>
<h3 id="2-Kafka集群搭建"><a href="#2-Kafka集群搭建" class="headerlink" title="2) Kafka集群搭建"></a>2) Kafka集群搭建</h3><ul>
<li>软件环境 1、linux一台或多台，大于等于2  2、已经搭建好的<strong>zookeeper</strong>集群  3、软件版本<strong>kafka_2.11-0.9.0.1.tgz</strong></li>
<li><p>创建目录并下载安装软件</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#下载软件</div><div class="line">cd /usr/local/src/</div><div class="line">wget  http://apache.opencas.org/kafka/<span class="number">0.9</span><span class="meta">.0</span><span class="meta">.1</span>/kafka_2<span class="meta">.11</span>-<span class="number">0.9</span><span class="meta">.0</span><span class="meta">.1</span>.tgz</div><div class="line"></div><div class="line">#解压软件</div><div class="line">tar -zxvf kafka_2<span class="meta">.11</span>-<span class="number">0.9</span><span class="meta">.0</span><span class="meta">.1</span>.tgz</div></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件<br>进入<strong>config</strong>目录，我们可以发现在目录下有很多文件，这里可以发现有<strong>Zookeeper</strong>文件，我们可以根据<strong>Kafka</strong>内带的<strong>zk</strong>集群来启动，但是建议使用独立的<strong>zk</strong>集群。这里主要关注：<strong>server.properties</strong>这个文件即可。<br><strong>server.properties</strong>配置注解：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">broker.id=<span class="number">0</span>  #当前机器在集群中的唯一标识，和zookeeper的myid性质一样</div><div class="line">port=<span class="number">19092</span> #当前kafka对外提供服务的端口默认是<span class="number">9092</span></div><div class="line">host.name=<span class="number">192.168</span>.<span class="number">7.100</span> #这个参数默认是关闭的，在<span class="number">0.8</span>.<span class="number">1</span>有个bug，DNS解析问题，失败率的问题。</div><div class="line">num<span class="selector-class">.network</span><span class="selector-class">.threads</span>=<span class="number">3</span> #这个是borker进行网络处理的线程数</div><div class="line">num<span class="selector-class">.io</span><span class="selector-class">.threads</span>=<span class="number">8</span> #这个是borker进行I/O处理的线程数</div><div class="line">log.dirs=/opt/kafka/kafkalogs/ #消息存放的目录，这个目录可以配置为“，”逗号分割的表达式，上面的num<span class="selector-class">.io</span><span class="selector-class">.threads</span>要大于这个目录的个数这个目录，如果配置多个目录，新创建的topic他把消息持久化的地方是，当前以逗号分割的目录中，那个分区数最少就放那一个</div><div class="line">socket<span class="selector-class">.send</span><span class="selector-class">.buffer</span><span class="selector-class">.bytes</span>=<span class="number">102400</span> #发送缓冲区buffer大小，数据不是一下子就发送的，先回存储到缓冲区了到达一定的大小后在发送，能提高性能</div><div class="line">socket<span class="selector-class">.receive</span><span class="selector-class">.buffer</span><span class="selector-class">.bytes</span>=<span class="number">102400</span> #kafka接收缓冲区大小，当数据到达一定大小后在序列化到磁盘</div><div class="line">socket<span class="selector-class">.request</span><span class="selector-class">.max</span><span class="selector-class">.bytes</span>=<span class="number">104857600</span> #这个参数是向kafka请求消息或者向kafka发送消息的请请求的最大数，这个值不能超过java的堆栈大小</div><div class="line">num.partitions=<span class="number">1</span> #默认的分区数，一个topic默认<span class="number">1</span>个分区数</div><div class="line">log<span class="selector-class">.retention</span><span class="selector-class">.hours</span>=<span class="number">168</span> #默认消息的最大持久化时间，<span class="number">168</span>小时，<span class="number">7</span>天</div><div class="line">message<span class="selector-class">.max</span><span class="selector-class">.byte</span>=<span class="number">5242880</span>  #消息保存的最大值<span class="number">5</span>M</div><div class="line">default<span class="selector-class">.replication</span><span class="selector-class">.factor</span>=<span class="number">2</span>  #kafka保存消息的副本数，如果一个副本失效了，另一个还可以继续提供服务</div><div class="line">replica<span class="selector-class">.fetch</span><span class="selector-class">.max</span><span class="selector-class">.bytes</span>=<span class="number">5242880</span>  #取消息的最大直接数</div><div class="line">log<span class="selector-class">.segment</span><span class="selector-class">.bytes</span>=<span class="number">1073741824</span> #这个参数是：因为kafka的消息是以追加的形式落地到文件，当超过这个值的时候，kafka会新起一个文件</div><div class="line">log<span class="selector-class">.retention</span><span class="selector-class">.check</span><span class="selector-class">.interval</span><span class="selector-class">.ms</span>=<span class="number">300000</span> #每隔<span class="number">300000</span>毫秒去检查上面配置的log失效时间（log<span class="selector-class">.retention</span><span class="selector-class">.hours</span>=<span class="number">168</span> ），到目录查看是否有过期的消息如果有，删除</div><div class="line">log<span class="selector-class">.cleaner</span><span class="selector-class">.enable</span>=false #是否启用log压缩，一般不用启用，启用的话可以提高性能</div><div class="line">zookeeper.connect=<span class="number">192.168</span>.<span class="number">7.100</span>:<span class="number">12181</span>,<span class="number">192.168</span>.<span class="number">7.101</span>:<span class="number">12181</span>,<span class="number">192.168</span>.<span class="number">7.107</span>:<span class="number">1218</span> #设置zookeeper的连接端口</div></pre></td></tr></table></figure>
</li>
</ul>
<p>实际的修改项为：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">broker.<span class="attribute">id</span>=0  #每台服务器的broker.id都不能相同</div><div class="line"><span class="attribute">listeners</span>=PLAINTEXT://192.168.43.40:9092</div><div class="line"><span class="attribute">port</span>=9092</div><div class="line">在log.retention.<span class="attribute">hours</span>=168 下面新增下面三项</div><div class="line">message.max.<span class="attribute">byte</span>=5242880</div><div class="line">default.replication.<span class="attribute">factor</span>=2</div><div class="line">replica.fetch.max.<span class="attribute">bytes</span>=5242880</div><div class="line">设置zookeeper的连接端口</div><div class="line">zookeeper.<span class="attribute">connect</span>=192.168.43.40:2181,192.168.43.41:2181,192.168.43.42:2181</div></pre></td></tr></table></figure></p>
<ul>
<li>启动<strong>zookeeper、kafka</strong>集群并测试 启动服务：<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">##启动zookeeper</div><div class="line">[root@host1 config]# cd /usr/local/src/zookeeper<span class="number">-3.4</span><span class="number">.6</span></div><div class="line">[root@host1 zookeeper<span class="number">-3.4</span><span class="number">.6</span>]# ./bin/zkServer.sh start ./conf/zoo.cfg</div><div class="line">##启动kafka</div><div class="line">[root@host1 zookeeper<span class="number">-3.4</span><span class="number">.6</span>]# cd /usr/local/src/kafka_2<span class="number">.11</span><span class="number">-0.9</span><span class="number">.0</span><span class="number">.1</span></div><div class="line">[root@host1 kafka_2<span class="number">.11</span><span class="number">-0.9</span><span class="number">.0</span><span class="number">.1</span>]# ./bin/kafka-server-start.sh -daemon ./config/server.properties</div></pre></td></tr></table></figure>
</li>
</ul>
<p>查看服务是否正常启动：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@host1 kafka_2<span class="number">.11</span><span class="number">-0.9</span><span class="number">.0</span><span class="number">.1</span>]# jps</div><div class="line"><span class="number">2356</span> QuorumPeerMain</div><div class="line"><span class="number">2550</span> Jps</div><div class="line"><span class="number">2413</span> Kafka</div></pre></td></tr></table></figure></p>
<p>创建<strong>Topic、Producer、Consumer</strong>测试:<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#创建Topic</span></div><div class="line"><span class="string">./kafka-topics.sh</span> <span class="params">--create</span> <span class="params">--zookeeper</span> 192.168.43.40<span class="function">:2181</span> <span class="params">--replication-factor</span> 2 <span class="params">--partitions</span> 1 <span class="params">--topic</span> test</div><div class="line"><span class="comment">#解释</span></div><div class="line"><span class="params">--replication-factor</span> 2   <span class="comment">#复制两份</span></div><div class="line"><span class="params">--partitions</span> 1 <span class="comment">#创建1个分区</span></div><div class="line"><span class="params">--topic</span> <span class="comment">#主题为test</span></div><div class="line"><span class="comment">#在一台服务器上创建一个发布者</span></div><div class="line"><span class="comment">#创建一个broker，发布者</span></div><div class="line"><span class="string">./kafka-console-producer.sh</span> <span class="params">--broker-list</span> 192.168.43.40<span class="function">:9092</span> <span class="params">--topic</span> test</div><div class="line"><span class="comment">#在一台服务器上创建一个订阅者</span></div><div class="line"><span class="string">./kafka-console-consumer.sh</span> <span class="params">--zookeeper</span> 192.168.43.40<span class="function">:2181</span> <span class="params">--topic</span> test <span class="params">--from-beginning</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、kafka是什么？&quot;&gt;&lt;a href=&quot;#一、kafka是什么？&quot; class=&quot;headerlink&quot; title=&quot;一、kafka是什么？&quot;&gt;&lt;/a&gt;一、kafka是什么？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;kafka&lt;/strong&gt;是一个分布式的、可分区的
    
    </summary>
    
      <category term="Kafka" scheme="https://hackbuteers.github.io/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="https://hackbuteers.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper - 从懵逼到淡定</title>
    <link href="https://hackbuteers.github.io/2017/06/18/ZooKeeper/"/>
    <id>https://hackbuteers.github.io/2017/06/18/ZooKeeper/</id>
    <published>2017-06-18T12:20:30.000Z</published>
    <updated>2017-06-18T12:25:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下描述中用<strong>zk</strong>代指<strong>ZooKeeper</strong>，源码解释均基于<strong>ZooKeeper 3.4.6</strong></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>04.11对Pigeon使用的zk集群执行变更导致集群4分钟不可用，详细如下：</p>
<ul>
<li>Pigeon使用的zk集群原本有5个节点（myid为0~5，以下描述中使用zk0指代id为0的节点，依此类推）</li>
<li>zk0、zk1、zk2提供对外提供服务（其中，zk2为leader），zk3、zk4从未对外提供服务（服务域名中未包含）</li>
<li>4月初机柜迁移，未服务的zk3、zk4在需要迁移的机柜上，将zk3、zk4先下线了</li>
<li>从提供服务的zk0、zk1、zk2里的配置中删除已经下线的zk3、zk4，择机重启</li>
<li>计划04.11进行重启节点的变更</li>
<li>此时之前下线的zk3、zk4已经关机，无法ping通</li>
<li>2017-04-11 11:19:13重启完zk1之后，集群选举持续无法成功，导致4分钟不可用</li>
<li>直到2017-04-11 11:23:01把其余两个节点（zk0、zk2）也重启了，集群才恢复可用</li>
</ul>
<p>变更之前在线下模拟了操作流程，一切正常，对客户端影响都在数秒以内。<br>这个问题，经过数天的排查，终于找到原因并且重现了。<br><strong>05.09</strong>对<strong>Kafka</strong>依赖的<strong>zk</strong>集群下线节点<strong>变更</strong>，利用前面的经验制定了下线的步骤，表现与预期相符，至此，验证了结论。<br>转眼，已经过了一个月了，小心翼翼地分享下彼时的排查过程，当然，写得异常混乱。</p>
<h2 id="懵逼"><a href="#懵逼" class="headerlink" title="懵逼"></a>懵逼</h2><p>对于故障排查，可以按照<strong>是否有现场、是否能重现、是否有详细上下文信息</strong>等几个因素分为划分，因素里面否越多，排查难度越大。<br><strong>04.11</strong>的问题等到排查的时候，属于<strong>无现场/不能重现/有详细上下文信息</strong>，毕竟有完整的<strong>ZooKeeper</strong>的日志。</p>
<p><strong>zk1</strong>日志内容摘取部分如下：</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下描述中用&lt;strong&gt;zk&lt;/strong&gt;代指&lt;strong&gt;ZooKeeper&lt;/strong&gt;，源码解释均基于&lt;strong&gt;ZooKeeper 3.4.6&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;header
    
    </summary>
    
      <category term="ZooKeeper" scheme="https://hackbuteers.github.io/categories/ZooKeeper/"/>
    
    
      <category term="ZooKeeper" scheme="https://hackbuteers.github.io/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper - Session Lifetime</title>
    <link href="https://hackbuteers.github.io/2017/06/17/ZK-session/"/>
    <id>https://hackbuteers.github.io/2017/06/17/ZK-session/</id>
    <published>2017-06-17T12:36:15.000Z</published>
    <updated>2017-06-18T12:17:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下描述中用<strong>zk</strong>代指<strong>ZooKeeper</strong>，源码解释均基于<strong>ZooKeeper 3.4.6</strong></p>
<h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><p>公司同事上周问了两个问题：</p>
<ul>
<li><strong>ZooKeeper Session</strong>在集群间传递吗？</li>
<li><strong>Session</strong>的<strong>expire</strong>是由<strong>Leader</strong>执行的，还是每个节点自己根据时间判断？</li>
</ul>
<p>第一个问题，必须的必啊，之前使用<strong>LogFormatter</strong>查看<strong>zk</strong>日志时：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">java -cp zookeeper-<span class="number">3.4</span>.6.jar:lib/log4j-<span class="number">1.2</span>.16.jar:lib/slf4j-log4j12-<span class="number">1.6</span>.1.jar:lib/slf4j-api-<span class="number">1.6</span>.1.jar org.apache.zookeeper.server.LogFormatter $logfile</div><div class="line"></div><div class="line">...</div><div class="line"><span class="number">5</span>/<span class="number">21</span>/<span class="number">17</span> <span class="number">9</span>:<span class="number">26</span>:<span class="number">48</span> PM CST session <span class="number">0x25c2a3ce5610001</span> cxid <span class="number">0x0</span> zxid <span class="number">0x20000000b</span> createSession <span class="number">30000</span></div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>看到了包含<strong>createSession</strong>请求的条目，所以比较确定创建<strong>Session</strong>的数据也是持久化的，而不仅仅是一个运行时的数据，这个也是<strong>zk</strong>比较奇特的一点。</p>
<h2 id="问题本身"><a href="#问题本身" class="headerlink" title="问题本身"></a>问题本身</h2><blockquote>
<p><strong>Session</strong>的<strong>expire</strong>是由<strong>Leader</strong>执行的，还是每个节点自己根据时间判断？</p>
</blockquote>
<p>如果仅仅是这一个问题，还是比较容易回答的：<strong>Session</strong>的<strong>expire</strong>是由<strong>Leader</strong>执行的。<br>对<strong>Leader</strong>进程进行<strong>jstack</strong>，结果截取如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">"SessionTracker" #28 prio=5 os_prio=31 tid=0x00007fe81e996800 nid=0x1133 in Object.wait() [0x000070001083e000]</div><div class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</div><div class="line">  at java.lang.Object.wait(Native Method)</div><div class="line">  at org.apache.zookeeper.server.SessionTrackerImpl.run(SessionTrackerImpl.java:146)</div><div class="line">  - locked &lt;0x000000076cf1b738&gt; (a org.apache.zookeeper.server.SessionTrackerImpl)</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>可以看到，<strong>Leader</strong>节点会有一个名为<strong>SessionTracker</strong>的线程执行<strong>SessionTrackerImpl.run</strong>方法。<br><strong>SessionTrackerImpl.run</strong>方法具体做的事情如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">synchronized public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">    try &#123;</div><div class="line">        <span class="keyword">while</span> (running) &#123;</div><div class="line">            // 获取当前时间，如果nextExpirationTime比当前时间要大，sleep掉这个gap，重新进入循环</div><div class="line">            currentTime = System.currentTimeMillis();</div><div class="line">            <span class="keyword">if</span> (nextExpirationTime &gt; currentTime) &#123;</div><div class="line">                this.wait(nextExpirationTime - currentTime);</div><div class="line">                <span class="built_in">continue</span>;</div><div class="line">            &#125;</div><div class="line">            // sessionSets是一个Map，key是一个时间戳t1，value是一个session的集合，</div><div class="line">            // 集合里面session的过期时间都为t1</div><div class="line">            SessionSet <span class="built_in">set</span>;</div><div class="line">            <span class="built_in">set</span> = sessionSets.remove(nextExpirationTime);</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">set</span> != null) &#123;</div><div class="line">                <span class="keyword">for</span> (SessionImpl s : set.sessions) &#123;</div><div class="line">                    // 设置session的状态为closing</div><div class="line">                    setSessionClosing(s.sessionId);</div><div class="line">                    // 调用expirer.expire来关闭session，这个时候会把closeSession的日志同步到其它节点</div><div class="line">                    // 会有Info级别日志：“Expiring session ... , timeout of xxx ms exceeded” 产生</div><div class="line">                    expirer.expire(s);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            // 更新nextExpirationTime，expirationInterval就是conf/zoo.cfg里面定义的tickTime</div><div class="line">            // 所以删除过期session的精度就是tickTime</div><div class="line">            nextExpirationTime += expirationInterval;</div><div class="line">        &#125;</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        LOG.error(<span class="string">"Unexpected interruption"</span>, e);</div><div class="line">    &#125;</div><div class="line">    LOG.info(<span class="string">"SessionTrackerImpl exited loop!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>问题回答到这里，显然是不够的。从我的角度，能看到延伸问题如下：</p>
<ul>
<li><strong>sessionId</strong>是如何构造的，如何保证唯一性</li>
<li>什么请求会触发更新<strong>Session</strong>的过期时间</li>
<li>如果客户端是连接到<strong>Follower</strong>的，<strong>Leader</strong>如何更新<strong>Session</strong>的过期时间</li>
<li>如果发生了重新选举，<strong>Leader</strong>更换之后，新的<strong>Leader</strong>是如何导入<strong>Session</strong>信息的</li>
<li><strong>Session</strong>和<strong>Ephemeral Node</strong>是如何结合的</li>
<li>清除过期<strong>Session</strong>的时候，会删除掉对应的<strong>Ephemeral Node</strong>么</li>
<li><strong>createSession</strong>操作完整的处理流程是怎样的</li>
</ul>
<h2 id="延伸问题"><a href="#延伸问题" class="headerlink" title="延伸问题"></a>延伸问题</h2><h2 id="问题A"><a href="#问题A" class="headerlink" title="问题A"></a>问题A</h2><blockquote>
<p><strong>sessionId</strong>是如何构造的，如何保证唯一性</p>
</blockquote>
<p><strong>zk</strong>日志中<strong>createSession</strong>时会打印出如下的日志：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Established session 0x15c30814aef0000 with negotiated timeout 30000 <span class="keyword">for</span><span class="built_in"> client </span>/x.x.x.x:60915</div></pre></td></tr></table></figure></p>
<p>上面这条日志中，<strong>sessionId</strong>为<strong>0x15c30814aef0000</strong>。在<strong>zk</strong>日志中，<strong>sessionId</strong>的类型为<strong>long</strong>，那么这个<strong>64位</strong>的数据是如何组成的，如何保证唯一性的呢？<br>依然是<strong>SessionTrackerImpl</strong>这个类中，有<strong>initializeNextSession</strong>这个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">initializeNextSession</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> nextSid = <span class="number">0</span>;</div><div class="line">    nextSid = (System.currentTimeMillis() &lt;&lt; <span class="number">24</span>) &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    nextSid =  nextSid | (id &lt;&lt;<span class="number">56</span>);</div><div class="line">    <span class="keyword">return</span> nextSid;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以，<strong>sessionId</strong>的构造如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">|<span class="number">63</span>...<span class="number">56</span>|<span class="number">55</span>...................................<span class="number">16</span>|<span class="number">15</span>............<span class="number">0</span>|</div><div class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">|  myid |                  timestamp            |    counter    |</div><div class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div></pre></td></tr></table></figure></p>
<p>对于<strong>sessionId</strong>这个<strong>64位</strong>的数据，<strong>高8位</strong>代表创建<strong>Session</strong>时所在的<strong>zk</strong>节点的<strong>id</strong>；<strong>中间40位</strong>代表<strong>zk节点</strong>当前角色（<strong>Leader</strong>或者<strong>Learner</strong>）在创建的时候的时间戳；<strong>低16位</strong>是一个计数器，初始值为<strong>0</strong>。<br>再看看上面日志里面的<strong>sessionId：0x15c30814aef0000</strong>：</p>
<ul>
<li><strong>高8位，0x1</strong>，代表这个<strong>Session</strong>是在<strong>myid=1</strong>的<strong>zk</strong>节点上面创建的</li>
<li><strong>中间40位，0x5c30814aef</strong>，代表<strong>myid=1</strong>的<strong>zk</strong>节点在初始化的时候时间戳的<strong>低40位</strong>是<strong>0x5c30814aef</strong></li>
<li><strong>低16位，0x0000</strong>，代表这是<strong>myid=1</strong>的<strong>zk</strong>节点在当前状态创建的第<strong>1</strong>个<strong>Session</strong><br>每个角色（<strong>Leader</strong>或者<strong>Learner</strong>）在构造的时候，都会调用<strong>createSessionTracker</strong>来创建一个<strong>SessionTracker</strong>对象。<br>这时候就会调用<strong>SessionTrackerImpl.initializeNextSession</strong>来设置<strong>nextSessionId</strong>。<br>初始设置完之后，每次通过<strong>createSession</strong>来获取<strong>sessionId</strong>时，所做的动作仅仅是进行<strong>nextSessionId++</strong>。</li>
</ul>
<h2 id="问题B"><a href="#问题B" class="headerlink" title="问题B"></a>问题B</h2><blockquote>
<p>什么请求会触发更新<strong>Session</strong>的过期时间</p>
</blockquote>
<p>客户端的任何请求都会触发更新<strong>Session</strong>的过期时间，包括客户端维持心跳的<strong>ping</strong>请求。<br><strong>Session</strong>过期时间的更新是在<strong>ZooKeeperServer.touch</strong>中进行的，通过<strong>BTrace</strong>可以拿到<strong>ZooKeeperServer.touch</strong>的调用栈如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.ZooKeeperServer</span><span class="selector-class">.touch</span>(ZooKeeperServer.java)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.ZooKeeperServer</span><span class="selector-class">.submitRequest</span>(ZooKeeperServer<span class="selector-class">.java</span>:<span class="number">667</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.ZooKeeperServer</span><span class="selector-class">.processPacket</span>(ZooKeeperServer<span class="selector-class">.java</span>:<span class="number">942</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.NIOServerCnxn</span><span class="selector-class">.readRequest</span>(NIOServerCnxn<span class="selector-class">.java</span>:<span class="number">373</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.NIOServerCnxn</span><span class="selector-class">.readPayload</span>(NIOServerCnxn<span class="selector-class">.java</span>:<span class="number">200</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.NIOServerCnxn</span><span class="selector-class">.doIO</span>(NIOServerCnxn<span class="selector-class">.java</span>:<span class="number">244</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.NIOServerCnxnFactory</span><span class="selector-class">.run</span>(NIOServerCnxnFactory<span class="selector-class">.java</span>:<span class="number">208</span>)</div><div class="line">java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread<span class="selector-class">.java</span>:<span class="number">745</span>)</div></pre></td></tr></table></figure></p>
<p>除了四字命令，客户端所有的访问操作都会触发<strong>Session</strong>更新过期时间。<br>再看看<strong>ZooKeeperServer.touch</strong>都会做哪些事情：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void touch(ServerCnxn cnxn) throws MissingSessionException &#123;</div><div class="line">    <span class="keyword">if</span> (cnxn == null) &#123;</div><div class="line">        <span class="built_in">return</span>;</div><div class="line">    &#125;</div><div class="line">    long id = cnxn.getSessionId();</div><div class="line">    int to = cnxn.getSessionTimeout();</div><div class="line">    <span class="keyword">if</span> (!sessionTracker.touchSession(id, to)) &#123;</div><div class="line">        throw new MissingSessionException(</div><div class="line">                <span class="string">"No session with sessionid 0x"</span> + Long.toHexString(id)</div><div class="line">                + <span class="string">" exists, probably expired and removed"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>ZooKeeperServer.touch</strong>其实只是调用了<strong>sessionTracker.touchSession</strong>来进行<strong>Session</strong>过期时间的更新。对于<strong>Leader</strong>和<strong>Learner</strong>这两个不同的角色，使用的<strong>sessionTracker</strong>的实现是不同的：</p>
<ul>
<li><strong>Leader</strong>使用的是<strong>SessionTrackerImpl</strong></li>
<li><strong>Learner</strong>使用的是<strong>LearnerSessionTracker</strong></li>
</ul>
<p>更新<strong>Session</strong>的过期时间其实都是在<strong>Leader</strong>中进行的，毕竟<strong>expire</strong>操作也是由<strong>Leader</strong>来执行的，所以这里只看<strong>SessionTrackerImpl</strong>中<strong>touchSession</strong>的实现：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">synchronized public boolean touchSession(long sessionId, int timeout) &#123;</div><div class="line">    <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</div><div class="line">        ZooTrace.logTraceMessage(LOG,</div><div class="line">                                 ZooTrace.CLIENT_PING_TRACE_MASK,</div><div class="line">                                 <span class="string">"SessionTrackerImpl --- Touch session: 0x"</span></div><div class="line">                + Long.toHexString(sessionId) + <span class="string">" with timeout "</span> + timeout);</div><div class="line">    &#125;</div><div class="line">    // 根据sessionId来获取session结构，如果不存在，或者已经是closing状态，说明对应的session已经过期</div><div class="line">    // 返回<span class="literal">false</span></div><div class="line">    SessionImpl s = sessionsById.get(sessionId);</div><div class="line">    <span class="keyword">if</span> (s == null || s.isClosing()) &#123;</div><div class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    // 如果session存在，计算出这个session下一次的过期时间</div><div class="line">    // roundToInterval保证计算出来的过期时间会是SessionTrackerImpl.expirationInterval的整数倍</div><div class="line">    // 像前面提到的，SessionTrackerImpl.expirationInterval的值就是conf/zoo.cfg里面定义的tickTime</div><div class="line">    long expireTime = roundToInterval(System.currentTimeMillis() + timeout);</div><div class="line">    // 如果session当前的过期时间比计算出来的时间还要大，直接返回<span class="literal">true</span>，这个可能是因为session的timeout设置变小了</div><div class="line">    <span class="keyword">if</span> (s.tickTime &gt;= expireTime) &#123;</div><div class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    // 下面的操作就是更新sessionSets，这样就不会在之前的过期时间s.tickTime的时候被过期掉了</div><div class="line">    SessionSet <span class="built_in">set</span> = sessionSets.get(s.tickTime);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">set</span> != null) &#123;</div><div class="line">        set.sessions.remove(s);</div><div class="line">    &#125;</div><div class="line">    // 更新session的过期时间</div><div class="line">    s.tickTime = expireTime;</div><div class="line">    <span class="built_in">set</span> = sessionSets.get(s.tickTime);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">set</span> == null) &#123;</div><div class="line">        <span class="built_in">set</span> = new SessionSet();</div><div class="line">        sessionSets.put(expireTime, <span class="built_in">set</span>);</div><div class="line">    &#125;</div><div class="line">    set.sessions.add(s);</div><div class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="问题C"><a href="#问题C" class="headerlink" title="问题C"></a>问题C</h2><blockquote>
<p>如果客户端是连接到<strong>Follower</strong>的，<strong>Leader</strong>如何更新<strong>Session</strong>的过期时间</p>
</blockquote>
<p>刚才<strong>问题B</strong>里面提到了<strong>Learner</strong>使用的是<strong>LearnerSessionTracker</strong>，所以再来看一下<strong>LearnerSessionTracker.touchSession</strong>的实现：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">synchronized public boolean touchSession(long sessionId, int sessionTimeout) &#123;</div><div class="line">    touchTable.put(sessionId, sessionTimeout);</div><div class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>似不似很简单，只有一次<strong>HashMap</strong>操作；<strong>touchTable</strong>会在<strong>LearnerSessionTracker.snapshot</strong>中使用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">synchronized HashMap&lt;Long, Integer&gt; <span class="function"><span class="title">snapshot</span></span>() &#123;</div><div class="line">    HashMap&lt;Long, Integer&gt; oldTouchTable = touchTable;</div><div class="line">    touchTable = new HashMap&lt;Long, Integer&gt;();</div><div class="line">    <span class="built_in">return</span> oldTouchTable;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过<strong>BTrace</strong>可以拿到<strong>LearnerSessionTracker.snapshot</strong>的调用栈如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.LearnerSessionTracker</span><span class="selector-class">.snapshot</span>(LearnerSessionTracker.java)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.LearnerZooKeeperServer</span><span class="selector-class">.getTouchSnapshot</span>(LearnerZooKeeperServer<span class="selector-class">.java</span>:<span class="number">58</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.Learner</span><span class="selector-class">.ping</span>(Learner<span class="selector-class">.java</span>:<span class="number">525</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.Follower</span><span class="selector-class">.processPacket</span>(Follower<span class="selector-class">.java</span>:<span class="number">112</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.Follower</span><span class="selector-class">.followLeader</span>(Follower<span class="selector-class">.java</span>:<span class="number">86</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.QuorumPeer</span><span class="selector-class">.run</span>(QuorumPeer<span class="selector-class">.java</span>:<span class="number">786</span>)</div></pre></td></tr></table></figure></p>
<p>可以看到<strong>Follower</strong>会在收到<strong>Leader</strong>发送过来的<strong>ping</strong>请求之后，把<strong>touchTable</strong>中的内容放在<strong>response</strong>之中，传回给<strong>Leader</strong>。<br>那么<strong>Leader</strong>收到<strong>Follower</strong>的<strong>ping response</strong>之后会怎么处理呢？<br>对应的逻辑在<strong>LearnerHandler.run</strong>中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> Leader.PING:</div><div class="line">    ByteArrayInputStream bis = new ByteArrayInputStream(qp</div><div class="line">            .getData());</div><div class="line">    DataInputStream dis = new DataInputStream(bis);</div><div class="line">    <span class="keyword">while</span> (dis.available() &gt; 0) &#123;</div><div class="line">        // sess为follower传过来的sessionId</div><div class="line">        long sess = dis.readLong();</div><div class="line">        // to为follower传过来的sessionId对应的timeout</div><div class="line">        int to = dis.readInt();</div><div class="line">        // 这里调用ZooKeeperServer.touch来更新session过期时间</div><div class="line">        leader.zk.touch(sess, to);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">break</span>;</div></pre></td></tr></table></figure></p>
<p>可以看到，<strong>Leader</strong>会把回包中的<strong>sessionId</strong>都<strong>touch</strong>一遍。<br><strong>Leader</strong>对<strong>Follower</strong>进行<strong>ping</strong>的时间间隔是多少呢？<br>如果间隔太大，可能导致<strong>Leader</strong>中<strong>Session</strong>的过期时间更新得不及时，导致<strong>Session</strong>信息被删除掉。<br>对应的逻辑在<strong>Leader.lead</strong>中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    // 等待 self.tickTime / 2 的时间</div><div class="line">    // 以tickTime为2s为例，这里leader对follower进行ping的时间间隔为1s</div><div class="line">    // 前面提到了session的过期时间会是expirationInterval的整数倍，expirationInterval就是tickTime</div><div class="line">    // 也就是说在leader连续两次检查session过期的间隔期间，至少会对follower进行一次ping操作</div><div class="line">    Thread.sleep(self.tickTime / 2);</div><div class="line">    ...</div><div class="line">    // 这里会对所有的Learner进行ping</div><div class="line">    <span class="keyword">for</span> (LearnerHandler f : getLearners()) &#123;</div><div class="line">        // Synced <span class="built_in">set</span> is used to check we have a supporting quorum, so only</div><div class="line">        // PARTICIPANT, not OBSERVER, learners should be used</div><div class="line">        <span class="keyword">if</span> (f.synced() &amp;&amp; f.getLearnerType() == LearnerType.PARTICIPANT) &#123;</div><div class="line">            syncedSet.add(f.getSid());</div><div class="line">        &#125;</div><div class="line">        f.ping();</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从代码中可以看到，<strong>ping</strong>的间隔足够小，不会导致<strong>Leader</strong>中<strong>Session</strong>的过期时间更新不及时。</p>
<h2 id="问题D"><a href="#问题D" class="headerlink" title="问题D"></a>问题D</h2><blockquote>
<p>如果发生了重新选举，<strong>Leader</strong>更换之后，新的<strong>Leader</strong>是如何导入<strong>session</strong>信息的</p>
</blockquote>
<p>奥秘就在<strong>SessionTrackerImpl</strong>的构造方法里面：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public SessionTrackerImpl(SessionExpirer expirer,</div><div class="line">            ConcurrentHashMap&lt;Long, Integer&gt; sessionsWithTimeout, int tickTime,</div><div class="line">            long sid)</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    this.sessionsWithTimeout = sessionsWithTimeout;</div><div class="line">    nextExpirationTime = roundToInterval(System.currentTimeMillis());</div><div class="line">    this.nextSessionId = initializeNextSession(sid);</div><div class="line">    <span class="keyword">for</span> (Entry&lt;Long, Integer&gt; e : sessionsWithTimeout.entrySet()) &#123;</div><div class="line">        addSession(e.getKey(), e.getValue());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，<strong>SessionTrackerImpl</strong>会遍历参数里面的<strong>sessionsWithTimeout</strong>，调用<strong>addSession</strong>重建<strong>sessionsById、sessionSets、sessionsWithTimeout</strong>这些用来管理<strong>session</strong>的数据结构。<br>新<strong>Leader</strong>上位会大赦天下，在<strong>addSession</strong>里面把所有的<strong>session</strong>全部<strong>touch</strong>一遍。<br>再回过头去看，新<strong>Leader</strong>是如何去创建<strong>SessionTrackerImpl</strong>对象的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">org.apache.zookeeper.server.SessionTrackerImpl.&lt;init&gt;(SessionTrackerImpl.java:97)</div><div class="line">org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.createSessionTracker(LeaderZooKeeperServer.java:81)</div><div class="line">org.apache.zookeeper.server.ZooKeeperServer.startup(ZooKeeperServer.java:405)</div><div class="line">org.apache.zookeeper.server.quorum.Leader.startZkServer(Leader.java:947)</div><div class="line">org.apache.zookeeper.server.quorum.Leader.lead(Leader.java:418)</div><div class="line">org.apache.zookeeper.server.quorum.QuorumPeer.run(QuorumPeer.java:799)</div></pre></td></tr></table></figure></p>
<p>具体是在<strong>ZooKeeperServer.createSessionTracker</strong>中创建<strong>SessionTrackerImpl</strong>对象的。<br><strong>ZooKeeperServer.createSessionTracker</strong>逻辑如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protected void <span class="function"><span class="title">createSessionTracker</span></span>() &#123;</div><div class="line">    sessionTracker = new SessionTrackerImpl(this, zkDb.getSessionWithTimeOuts(),</div><div class="line">            tickTime, 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么，<strong>zkDb.getSessionWithTimeOuts()</strong>是如何通过现在的数据进行<strong>sessionsWithTimeout</strong>的重建的呢？<br>逻辑在<strong>ZKDatabase.loadDataBase</strong>中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public long loadDataBase() throws IOException &#123;</div><div class="line">    PlayBackListener listener=new <span class="function"><span class="title">PlayBackListener</span></span>()&#123;</div><div class="line">        public void onTxnLoaded(TxnHeader hdr,Record txn)&#123;</div><div class="line">            Request r = new Request(null, 0, hdr.getCxid(),hdr.getType(),</div><div class="line">                    null, null);</div><div class="line">            r.txn = txn;</div><div class="line">            r.hdr = hdr;</div><div class="line">            r.zxid = hdr.getZxid();</div><div class="line">            addCommittedProposal(r);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    long zxid = snapLog.restore(dataTree,sessionsWithTimeouts,listener);</div><div class="line">    initialized = <span class="literal">true</span>;</div><div class="line">    <span class="built_in">return</span> zxid;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>综上，新<strong>Leader</strong>在进行<strong>Leader.lead()</strong>时，会先调用<strong>zk.loadData()</strong>把数据从持久化文件（<strong>snapshot/log</strong>）中恢复出<strong>sessionsWithTimeout</strong>，然后调用<strong>startZkServer</strong>创建<strong>SessionTrackerImpl</strong>重构<strong>session</strong>相关的数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">void lead() throws IOException, InterruptedException &#123;</div><div class="line">    self.end_fle = System.currentTimeMillis();</div><div class="line">    LOG.info(<span class="string">"LEADING - LEADER ELECTION TOOK - "</span> +</div><div class="line">          (self.end_fle - self.start_fle));</div><div class="line">    self.start_fle = 0;</div><div class="line">    self.end_fle = 0;</div><div class="line"></div><div class="line">    zk.registerJMX(new LeaderBean(this, zk), self.jmxLocalPeerBean);</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        self.tick = 0;</div><div class="line">        zk.loadData();</div><div class="line">        ...</div><div class="line">        startZkServer();</div><div class="line">        ...</div><div class="line">    &#125; finally &#123;</div><div class="line">        zk.unregisterJMX(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="问题E"><a href="#问题E" class="headerlink" title="问题E"></a>问题E</h2><blockquote>
<p><strong>Session</strong>和<strong>Ephemeral Node</strong>是如何结合的</p>
</blockquote>
<p>在<strong>PrepRequestProcessor.pRequest2Txn</strong>中，可以看到下面的逻辑：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> OpCode.create:<span class="type"></span></div><div class="line">    ...</div><div class="line">    <span class="comment">// 首先判断创建的Znode的parent是否为ephemeral，如果是，直接抛出异常</span></div><div class="line">    <span class="comment">// 因为 Ephemerals cannot have children，临时节点是不能有子节点的</span></div><div class="line">    boolean ephemeralParent = parentRecord.stat.getEphemeralOwner() != <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (ephemeralParent) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">KeeperException</span>.NoChildrenForEphemeralsException(path);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 更新新的cversion</span></div><div class="line">    int <span class="keyword">new</span><span class="type">Cversion</span> = parentRecord.stat.getCversion()+<span class="number">1</span>;</div><div class="line">    request.txn = <span class="keyword">new</span> <span class="type">CreateTxn</span>(path, createRequest.getData(),</div><div class="line">            listACL,</div><div class="line">            createMode.isEphemeral(), <span class="keyword">new</span><span class="type">Cversion</span>);</div><div class="line">    StatPersisted s = <span class="keyword">new</span> <span class="type">StatPersisted</span>();</div><div class="line">    <span class="keyword">if</span> (createMode.isEphemeral()) &#123;</div><div class="line">        <span class="comment">// 这里会关连ephemeral node和相关的session信息</span></div><div class="line">        s.setEphemeralOwner(request.sessionId);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 深拷贝出来一个parentRecord，设置一些相关的信息</span></div><div class="line">    parentRecord = parentRecord.duplicate(request.hdr.getZxid());</div><div class="line">    parentRecord.childCount++;</div><div class="line">    parentRecord.stat.setCversion(<span class="keyword">new</span><span class="type">Cversion</span>);</div><div class="line">    addChangeRecord(parentRecord);</div><div class="line">    addChangeRecord(<span class="keyword">new</span> <span class="type">ChangeRecord</span>(request.hdr.getZxid(), path, s,</div><div class="line">            <span class="number">0</span>, listACL));</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<p>在<strong>Znode</strong>创建的过程，就会设置<strong>Znode</strong>对应的<strong>Ephemeral Owner</strong>。</p>
<h2 id="问题F"><a href="#问题F" class="headerlink" title="问题F"></a>问题F</h2><blockquote>
<p>清除过期<strong>Session</strong>的时候，会删除掉对应的<strong>Ephemeral Node</strong>么</p>
</blockquote>
<p>清除过期<strong>Session</strong>，最终会调用关闭<strong>Session</strong>的操作，<strong>ZooKeeperServer.close</strong>的逻辑如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">long</span> sessionId)</span> </span>&#123;</div><div class="line">    submitRequest(<span class="keyword">null</span>, sessionId, OpCode.closeSession, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再看看<strong>zk</strong>请求收到<strong>OpCode.closeSession</strong>时，是如何处理的。<br>同样在<strong>PrepRequestProcessor.pRequest2Txn</strong>中（<strong>PrepRequestProcessor</strong>处理了很多与<strong>zk api</strong>语义相关的逻辑），可以看到：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> OpCode.<span class="string">closeSession:</span></div><div class="line">    <span class="comment">// We don't want to do this check since the session expiration thread</span></div><div class="line">    <span class="comment">// queues up this operation without being the session owner.</span></div><div class="line">    <span class="comment">// this request is the last of the session so it should be ok</span></div><div class="line">    <span class="comment">//zks.sessionTracker.checkSession(request.sessionId, request.getOwner());</span></div><div class="line">    HashSet&lt;String&gt; es = zks.getZKDatabase()</div><div class="line">            .getEphemerals(request.sessionId);</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (zks.outstandingChanges) &#123;</div><div class="line">        <span class="keyword">for</span> (ChangeRecord <span class="string">c :</span> zks.outstandingChanges) &#123;</div><div class="line">            <span class="keyword">if</span> (c.stat == <span class="literal">null</span>) &#123;</div><div class="line">                <span class="comment">// Doing a delete</span></div><div class="line">                es.remove(c.path);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c.stat.getEphemeralOwner() == request.sessionId) &#123;</div><div class="line">                es.add(c.path);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (String <span class="string">path2Delete :</span> es) &#123;</div><div class="line">            addChangeRecord(<span class="keyword">new</span> ChangeRecord(request.hdr.getZxid(),</div><div class="line">                    path2Delete, <span class="literal">null</span>, <span class="number">0</span>, <span class="literal">null</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        zks.sessionTracker.setSessionClosing(request.sessionId);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到：<br><strong>Leader</strong>收到<strong>OpCode.closeSession</strong>请求之后（<strong>PrepRequestProcessor</strong>只会存在于<strong>Leader</strong>中），会找出<strong>zKDatabase</strong>中所有和这个<strong>Session</strong>相关的<strong>Ephemeral Node</strong>的路径。<br>另外，还会找出<strong>zks.outstandingChanges</strong>里面，<strong>EphemeralOwner</strong>设置为当前<strong>session</strong>的所有路径。<br>然后把所有这些路径都调用<strong>addChangeRecord</strong>添加到<strong>zks.outstandingChanges</strong>中。<br>但是这些并非真正地应用到内存中的<strong>DataTree</strong>上，真正的删除节点的操作并不在这里。之前在<strong>zk</strong>日志里面发现过这样的记录：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Deleting ephemeral <span class="keyword">node</span> <span class="title">/mypath</span> for session <span class="number">0</span>x153501f0a4a05cb</div></pre></td></tr></table></figure></p>
<p>这行日志打印由方法<strong>DataTree.killSession</strong>打印的：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">void killSession(<span class="keyword">long</span> session, <span class="keyword">long</span> zxid) &#123;</div><div class="line">    <span class="comment">// the list is already removed from the ephemerals</span></div><div class="line">    <span class="comment">// so we do not have to worry about synchronizing on</span></div><div class="line">    <span class="comment">// the list. This is only called from FinalRequestProcessor</span></div><div class="line">    <span class="comment">// so there is no need for synchronization. The list is not</span></div><div class="line">    <span class="comment">// changed here. Only create and delete change the list which</span></div><div class="line">    <span class="comment">// are again called from FinalRequestProcessor in sequence.</span></div><div class="line">    HashSet&lt;String&gt; <span class="keyword">list</span> = ephemerals.remove(session);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">list</span> != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (String path : <span class="keyword">list</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                deleteNode(path, zxid);</div><div class="line">                <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</div><div class="line">                    LOG</div><div class="line">                            .debug(<span class="string">"Deleting ephemeral node "</span> + path</div><div class="line">                                    + <span class="string">" for session 0x"</span></div><div class="line">                                    + <span class="keyword">Long</span>.toHexString(session));</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (NoNodeException e) &#123;</div><div class="line">                LOG.warn(<span class="string">"Ignoring NoNodeException for path "</span> + path</div><div class="line">                        + <span class="string">" while removing ephemeral for dead session 0x"</span></div><div class="line">                        + <span class="keyword">Long</span>.toHexString(session));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用栈如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.DataTree</span><span class="selector-class">.killSession</span>(DataTree.java)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.DataTree</span><span class="selector-class">.processTxn</span>(DataTree<span class="selector-class">.java</span>:<span class="number">818</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.ZKDatabase</span><span class="selector-class">.processTxn</span>(ZKDatabase<span class="selector-class">.java</span>:<span class="number">329</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.ZooKeeperServer</span><span class="selector-class">.processTxn</span>(ZooKeeperServer<span class="selector-class">.java</span>:<span class="number">994</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.FinalRequestProcessor</span><span class="selector-class">.processRequest</span>(FinalRequestProcessor<span class="selector-class">.java</span>:<span class="number">116</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.Leader</span><span class="variable">$ToBeAppliedRequestProcessor</span>.processRequest(Leader<span class="selector-class">.java</span>:<span class="number">644</span>)</div><div class="line">org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.CommitProcessor</span><span class="selector-class">.run</span>(CommitProcessor<span class="selector-class">.java</span>:<span class="number">74</span>)</div></pre></td></tr></table></figure></p>
<p>删掉<strong>Ephemeral Node</strong>到底意味着什么，和删除<strong>Persistent Node</strong>是一样的么？<br>关闭<strong>Session</strong>的时候删除<strong>Ephemeral Node</strong>会应用到日志里面么？<br>带着上面的疑问，使用<strong>zkCli.sh</strong>连接到<strong>server</strong>，创建<strong>Ephemeral Node</strong>，然后退出。<br>观察到<strong>log</strong>如下：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">5/24/17 1</span>:<span class="number">57</span>:<span class="number">56</span> PM CST session <span class="number">0</span>x15c38d<span class="number">9b8000001</span> cxid <span class="number">0</span>x0 zxid <span class="number">0x100000004</span> createSession <span class="number">30000</span></div><div class="line"><span class="number">5/24/17 1</span>:<span class="number">58</span>:<span class="number">20</span> PM CST session <span class="number">0</span>x15c38d<span class="number">9b8000001</span> cxid <span class="number">0</span>x1 zxid <span class="number">0x100000005</span> create '/ephemeral,#<span class="number">6</span>b6b6b,v&#123;s&#123;<span class="number">31</span>,s&#123;'world,'anyone&#125;&#125;&#125;,T,<span class="number">2</span></div><div class="line"><span class="number">5/24/17 1</span>:<span class="number">58</span>:<span class="number">53</span> PM CST session <span class="number">0</span>x15c38d<span class="number">9b8000001</span> cxid <span class="number">0</span>x2 zxid <span class="number">0x100000006</span> closeSession null</div></pre></td></tr></table></figure></p>
<p>可见，关闭<strong>Session</strong>的时候删除<strong>Ephemeral Node</strong>并不会应用到日志中，只会从内存的<strong>DataTree</strong>中删除对应的数据。删除<strong>DataTree</strong>中数据的逻辑在<strong>DataTree.deleteNode</strong>。<br>关于<strong>DataTree</strong>，我觉得有一个很有意思的地方，从<strong>DataTree</strong>的<strong>javadoc</strong>里面可以看到：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">* The tree maintains <span class="literal">two</span> parallel data structures: <span class="keyword">a</span> hashtable that maps <span class="built_in">from</span></div><div class="line">* full paths <span class="built_in">to</span> DataNodes <span class="keyword">and</span> <span class="keyword">a</span> tree <span class="keyword">of</span> DataNodes. All accesses <span class="built_in">to</span> <span class="keyword">a</span> path is</div><div class="line">* through <span class="keyword">the</span> hashtable. The tree is traversed only when serializing <span class="built_in">to</span> disk.</div></pre></td></tr></table></figure></p>
<p><strong>javadoc</strong>说的是，维护了两个数据结构，一个是全路径到<strong>DataNode</strong>的映射（<strong>DataTree.nodes</strong>这个<strong>field</strong>），另外一个是所有<strong>DataNode</strong>的<strong>tree</strong>（<strong>DataTree.root</strong>这个<strong>field</strong>）。然而，这个<strong>tree</strong>呢，和我们传统意义上的<strong>tree</strong>（至少我们写二叉树实现的时候）是不太一样的：<strong>DataNode</strong>里面并没有指针/对象指向所有的子节点，仅仅有所有子节点的路径。<br>所以节点对象的定位，都是通过<strong>DataTree.nodes</strong>来查找的。所以删除<strong>Ephemeral Node</strong>，只需要删除这个<strong>Znode</strong>在<strong>DataTree.nodes</strong>中的条目即可。</p>
<h2 id="问题G"><a href="#问题G" class="headerlink" title="问题G"></a>问题G</h2><blockquote>
<p><strong>createSession</strong>操作完整的处理流程是怎样的</p>
</blockquote>
<p>这个问题再描述具体点：如果应用使用<strong>zk</strong>客户端连接到<strong>zk</strong>集群的一个<strong>Follower</strong>结点，那么会是一个什么逻辑呢？<br><strong>Follower</strong>的处理<br>请求到达<strong>Follower</strong>后，<strong>Follower</strong>会调用<strong>ZooKeeperServer.submitRequest</strong>，然后会调用<strong>firstProcessor.processRequest</strong>，对于<strong>Follower</strong>来说，<strong>ZooKeeperServer</strong>的实现是<strong>FollowerZooKeeperServer</strong>，这个实现里面的<strong>firstProcessor</strong>为<strong>FollowerReqeustProcessor</strong>。<br>对于不同的<strong>ZooKeeperServer</strong>子类来说，比较重要的是<strong>setupRequestProcessors</strong>这个方法，<strong>setupRequestProcessors</strong>这个方法会去生成某个角色的处理链，<strong>Standalone、Follower、Leader</strong>这三种角色的处理链都是各有不同的（<strong>Observer</strong>这个角色在我们的部署中没有，暂时偷懒忽略:)）。<br>对于<strong>Follower</strong>来说，主线处理链是：<br><strong>FollowerReqeustProcessor</strong> =&gt; <strong>CommitProcessor</strong> =&gt; <strong>FinalRequestProcessor</strong><br>另外，还有一条辅线处理链：<br><strong>SyncReqeustProcessor</strong> =&gt; <strong>SendAckRequestProcessor</strong><br>下面逐个来讲解下这几种<strong>RequestProcessor</strong>。</p>
<h2 id="主线处理链"><a href="#主线处理链" class="headerlink" title="主线处理链"></a>主线处理链</h2><p><strong>FollowerReqeustProcessor</strong>是<strong>Follower</strong>专有的<strong>RequestProcessor</strong>，会做两件事情：</p>
<ul>
<li>把收到的情况一股脑儿地传给<strong>nextProcessor</strong>，也就是<strong>CommitRequestProcessor</strong></li>
<li>调用<strong>zks.getFollower().request(request)</strong>把写请求转发给<strong>Leader</strong></li>
</ul>
<hr>
<p><strong>CommitProcessor</strong>比较重要，<strong>follower</strong>和<strong>leader</strong>的处理链都有它。<br>它的名字比较特殊，<strong>RequestProcessor</strong>接口所有的实现里面，就它名字特殊，其它实现类名的<strong>suffix</strong>都是<strong>RequestProcessor</strong>，就它不是，当然，这是我纯扯淡:)。<br><strong>CommitProcessor</strong>里面有两个队列：<strong>queuedRequests</strong>和<strong>committedRequests</strong>。<strong>queuedRequests</strong>里面是所有应用过来的请求，<strong>committedRequests</strong>里面是所有已经被<strong>committed</strong>的请求。只有<strong>CommitProcessor.commit</strong>这个方法会往<strong>committedRequests</strong>这个队列添加元素，而<strong>CommitProcessor.commit</strong>的调用有以下两个地方：</p>
<ul>
<li>在<strong>Follower</strong>中，Follower.processPacket方法中收到<strong>Leader</strong>发过来的<strong>Leader.COMMIT</strong>会调用<strong>FollowerZooKeeperServer.commit</strong>，然后会调用<strong>CommitProcessor.commit</strong></li>
<li>在<strong>Leader</strong>中，<strong>Leader.processAck</strong>中如果收到<strong>Ack</strong>的个数达到了大多数会调用<strong>CommitProcessor.commit；Leader.processAck</strong>有两个调用的地方：</li>
<li>处理<strong>Leader</strong>自己的<strong>Ack</strong>，在<strong>AckRequestProcessor.processRequest</strong>中（<strong>AckRequestProcessor</strong>是<strong>leader</strong>专有的）会调用</li>
<li>处理<strong>Follower</strong>回复的<strong>Ack</strong>，在<strong>LearnerHandler.run</strong>中处理<strong>Follower</strong>发来的<strong>Leader.ACK</strong>请求时会调用</li>
</ul>
<p>好，扯远了，收回来。<strong>CommitProcessor.run</strong>的<strong>loop</strong>逻辑如下：</p>
<ul>
<li>对<strong>toProcess</strong>队列里面的所有请求调用<strong>nextProcessor.processRequest</strong>，也就是<strong>FinalRequestProcessor.processRequest</strong>，<strong>toProcess</strong>队列只有读请求和已经<strong>committed</strong>的写请求</li>
<li>如果<strong>committedRequests</strong>中有请求，就把这个请求拉出来，和当前的<strong>nextPending</strong>（<strong>nextPending</strong>可以理解为当前正在等<strong>commit</strong>的写请求）对比，如果匹配，就把<strong>nextPending</strong>放入<strong>toProcess</strong>队列中，并清空<strong>nextPending</strong></li>
<li>如果<strong>nextPending</strong>不为空，说明有写请求还在等<strong>commit</strong>，不用处理<strong>queuedRequests</strong>队列里面的请求了，重新进入<strong>loop</strong></li>
<li>处理<strong>queuedRequests</strong>队列里面的请求，如果是写操作，设置<strong>nextPending</strong>，重新进入<strong>loop</strong>；如果是读操作，添加到<strong>toProcess</strong>队列中，有多少添加多少</li>
</ul>
<p>通过以上逻辑可以看到写请求是会阻塞后面的读请求的，所以，如果对一致性要求不是那么强的读请求，<strong>zk</strong>的访问有必要做读写分离呢？</p>
<p><strong>FinalRequestProcessor</strong>也是一个比较重要的角儿，<strong>Standalone、Follower、Leader</strong>这三种角色的处理链中都有它的存在，到达这个<strong>RequestProcessor</strong>的请求和放在<strong>CommitProcessor.toProcess</strong>一样，只有读请求和已经<strong>committed</strong>的写请求。<br><strong>FinalRequestProcessor</strong>会做两件事情：</p>
<ul>
<li>操作<strong>ZooKeeperServer.zkDb</strong></li>
<li>返回<strong>response</strong>给客户端</li>
</ul>
<h2 id="辅线处理链"><a href="#辅线处理链" class="headerlink" title="辅线处理链"></a>辅线处理链</h2><p><strong>SyncReqeustProcessor</strong>也是比较重要的，和<strong>FinalRequestProcessor</strong>一样，也是<strong>Standalone、Follower、Leader</strong>这三种角色都会有的。这个<strong>RequestProcessor</strong>其实只做一件事情：写日志，可以认为是两阶段提交的第一阶段。<br><strong>SyncReqeustProcessor.processRequest</strong>有两个调用的地方：</p>
<ul>
<li>在<strong>Follower</strong>中，<strong>Follower.processPacket</strong>方法中收到<strong>Leader</strong>发过来的<strong>Leader.PROPOSAL</strong>会调用<strong>FollowerZooKeeperServer.logRequest</strong>，然后会调用<strong>SyncReqeustProcessor.processRequest</strong></li>
<li>在<strong>Leader</strong>中，<strong>ProposalRequestProcessor.processRequest</strong>对于写操作，不仅会<strong>zks.getLeader().propose(request)</strong>通知所有<strong>Follower</strong>去写日志，还会调用<strong>SyncReqeustProcessor.processRequest</strong>来写入<strong>Leader</strong>自己的本地日志。</li>
</ul>
<p><strong>SendAckRequestProcessor</strong>是<strong>Follower</strong>专有的<strong>RequestProcessor</strong>，也是唯一实现了<strong>Flushable</strong>接口的<strong>RequestProcessor</strong>。做的事情比较纯粹，给<strong>Leader</strong>回一个<strong>Leader.ACK</strong>的<strong>QuorumPacket</strong>。</p>
<h2 id="Leader的处理"><a href="#Leader的处理" class="headerlink" title="Leader的处理"></a>Leader的处理</h2><p>上述<strong>Follower</strong>的处理中，我们提到了<strong>FollowerRequestProcessor</strong>会：</p>
<blockquote>
<p>调用<strong>zks.getFollower().request(request)</strong>把写请求转发给<strong>Leader</strong></p>
</blockquote>
<p>从这一刻开始，<strong>Leader</strong>的处理开始登上历史舞台。<br>在<strong>LearnerHandler.run</strong>中收到<strong>Leader.REQUEST</strong>，会调用<strong>leader.zk.submitRequest(si)</strong>，代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="type">Leader</span>.<span class="type">REQUEST</span>:</div><div class="line">    bb = <span class="type">ByteBuffer</span>.wrap(qp.getData());</div><div class="line">    sessionId = bb.getLong();</div><div class="line">    cxid = bb.getInt();</div><div class="line">    <span class="class"><span class="keyword">type</span> </span>= bb.getInt();</div><div class="line">    bb = bb.slice();</div><div class="line">    <span class="type">Request</span> si;</div><div class="line">    <span class="comment">// 对于OpCode.sync请求，会创建一个不一样的包，LearnerSyncRequest</span></div><div class="line">    <span class="keyword">if</span>(<span class="class"><span class="keyword">type</span> <span class="title">==</span> <span class="title">OpCode</span>.<span class="title">sync</span>)</span>&#123;</div><div class="line">        si = <span class="keyword">new</span> <span class="type">LearnerSyncRequest</span>(<span class="keyword">this</span>, sessionId, cxid, <span class="class"><span class="keyword">type</span>, <span class="title">bb</span>, <span class="title">qp</span>.<span class="title">getAuthinfo</span>(<span class="params"></span>))</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        si = <span class="keyword">new</span> <span class="type">Request</span>(<span class="literal">null</span>, sessionId, cxid, <span class="class"><span class="keyword">type</span>, <span class="title">bb</span>, <span class="title">qp</span>.<span class="title">getAuthinfo</span>(<span class="params"></span>))</span>;</div><div class="line">    &#125;</div><div class="line">    si.setOwner(<span class="keyword">this</span>);</div><div class="line">    <span class="comment">// 这里会调用submitRequest，让LeaderZooKeeperServer来处理请求</span></div><div class="line">    leader.zk.submitRequest(si);</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<p>上面讲<strong>Follower</strong>的处理时，提到了：</p>
<blockquote>
<p>请求到达<strong>Follower</strong>后，<strong>Follower</strong>会调用<strong>ZooKeeperServer.submitRequest</strong>，然后会调用<strong>firstProcessor.processRequest</strong></p>
</blockquote>
<p><strong>Leader</strong>和<strong>Follower</strong>一样，都会调用<strong>ZooKeeperServer.submitRequest</strong>，这里面逻辑是一样的，区别在于处理链不一样。<strong>Leader</strong>的处理链是所有角色中最复杂的，涉及到7个<strong>RequestProcessor</strong>，如下图所示：<br><a href="http://orimyicvd.bkt.clouddn.com/Request.png" data-fancybox="images" target="_blank" rel="external"><img src="http://orimyicvd.bkt.clouddn.com/Request.png"></a><br><strong>CommitProcessor、SyncRequestProcessor、FinalRequestProcessor</strong>都是老熟人了，在上面刚见过。下面介绍下另外的4个<strong>RequestProcessor</strong>。<br><strong>PrepRequestProcessor</strong>并非是<strong>Leader</strong>专有的，<strong>Standalone</strong>模式也会有。这个<strong>RequestProcessor</strong>也是所有<strong>RequestProcessor</strong>实现中最复杂的，从这个类对应代码文件的行数就可以看出来：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">find * -name <span class="string">'*Processor.java'</span>  |xargs wc -l |sort -k <span class="number">1</span></div><div class="line">   <span class="number">44</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server/RequestProcessor.java</div><div class="line">   <span class="number">48</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server/UnimplementedRequestProcessor.java</div><div class="line">   <span class="number">54</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server<span class="regexp">/quorum/</span>AckRequestProcessor.java</div><div class="line">   <span class="number">80</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server<span class="regexp">/quorum/</span>SendAckRequestProcessor.java</div><div class="line">   <span class="number">93</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server<span class="regexp">/quorum/</span>ProposalRequestProcessor.java</div><div class="line">  <span class="number">112</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server<span class="regexp">/quorum/</span>FollowerRequestProcessor.java</div><div class="line">  <span class="number">126</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server<span class="regexp">/quorum/</span>ObserverRequestProcessor.java</div><div class="line">  <span class="number">128</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server<span class="regexp">/quorum/</span>ReadOnlyRequestProcessor.java</div><div class="line">  <span class="number">192</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server<span class="regexp">/quorum/</span>CommitProcessor.java</div><div class="line">  <span class="number">235</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server/SyncRequestProcessor.java</div><div class="line">  <span class="number">418</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server/FinalRequestProcessor.java</div><div class="line">  <span class="number">766</span> src<span class="regexp">/java/</span>main<span class="regexp">/org/</span>apache<span class="regexp">/zookeeper/</span>server/PrepRequestProcessor.java</div></pre></td></tr></table></figure></p>
<p>复杂也是正常的，毕竟与<strong>zk api</strong>语义相关的逻辑基本都在这里实现的。<br><strong>PrepRequestProcessor.pRequest</strong>是这个<strong>RequestProcessor</strong>最重要的实现，这个方法里面做两件事情：</p>
<ul>
<li>调用<strong>pRequest2Txn</strong>设置部分请求的<strong>request.hdr</strong>和<strong>request.txn</strong>，<strong>pRequest2Txn</strong>里面会完成一些接口语义相关的逻辑，比如上面提到的，收到<strong>OpCode.create</strong>请求时会去设置<strong>Ephemeral Owner</strong></li>
<li>调用<strong>nextProcessor.processRequest</strong>，也就是<strong>ProposalRequestProcessor.processRequest</strong></li>
</ul>
<p><strong>ProposalRequestProcessor</strong>是<strong>Leader</strong>专有的<strong>RequestProcessor</strong>，会做三件事情：</p>
<ul>
<li>调用<strong>nextProcessor.processRequest</strong>，也就是<strong>CommitProcessor.processRequest</strong></li>
<li>对于设置了<strong>request.hdr</strong>的请求，调用<strong>zks.getLeader().propose(request)</strong>向所有的<strong>Follower</strong>发送<strong>Leader.PROPOSAL</strong>请求。上面的描述中提到了<strong>Follower</strong>收到<strong>Leader</strong>发送过来的<strong>Leader.PROPOSAL</strong>请求后，最终会调用<strong>SyncReqeustProcessor.processRequest</strong>去写入日志。那么<strong>Leader</strong>自己的日志什么时候写呢，就在下一步了。</li>
<li>对于设置了<strong>request.hdr</strong>的请求，调用<strong>syncProcessor.processRequest</strong>来向<strong>Leader</strong>自己的日志里写入记录。这里会有疑问，什么是”设置了<strong>request.hdr</strong>的请求”呢？除了<strong>create、delete、setData、setACL、multi、createSession、closeSession</strong>这些常见的写操作之外，还有一个<strong>check</strong>。</li>
</ul>
<p><strong>ToBeAppliedRequestProcessor</strong>是<strong>Leader</strong>专有的<strong>RequestProcessor</strong>，也是唯一一个内部类的<strong>RequestProcessor</strong>。做的事情非常简单，只是在<strong>CommitProcessor</strong>和<strong>FinalRequestProcessor</strong>之前做个桥接。唯一的作用在于维护一个<strong>toBeApplied</strong>的队列，这个队列里面包括了已经达到<strong>quorum</strong>，但是还没有应用到<strong>FinalRequestProcessor</strong>的<strong>Proposal</strong>。</p>
<p><strong>AckRequestProcessor</strong>是<strong>Leader</strong>专有的<strong>RequestProcessor</strong>，和<strong>Follower</strong>专有的<strong>SendAckRequestProcessor</strong>长得很像，做的逻辑也比较类似。调用<strong>leader.processAck</strong>，相当于写一个本地的<strong>Ack</strong>。<br>综上所述，<strong>CreateSession</strong>操作完整的处理流程如下图：<br><a href="http://orimyicvd.bkt.clouddn.com/CreateSession.png" data-fancybox="images" target="_blank" rel="external"><img src="http://orimyicvd.bkt.clouddn.com/CreateSession.png"></a></p>
<h2 id="选做题"><a href="#选做题" class="headerlink" title="选做题"></a>选做题</h2><p>分享这个问题的时候遇到两个问题，我不太能回答上来，想请大家帮我解答一下：</p>
<ul>
<li>为什么不能统一地从<strong>Leader</strong>拿<strong>sessionId</strong>？其实想想，也是可以的，只是<strong>createSession</strong>是<strong>synchronized</strong>，在<strong>Follower</strong>上操作能稍微提高一些并发。</li>
<li>为什么大量使用<strong>synchronized</strong>，而不是使用锁？<strong>zk</strong>的代码里面，确实是非常大量地使用<strong>synchronized</strong>。只是因为<strong>zk</strong>不是很注重性能，使用<strong>synchronized</strong>会使代码看起来更易懂一些么。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.tonyseek.com/post/zookeeper-sessionid/" target="_blank" rel="external">https://blog.tonyseek.com/post/zookeeper-sessionid/</a></li>
<li><a href="http://damacheng009.iteye.com/blog/2085968" target="_blank" rel="external">http://damacheng009.iteye.com/blog/2085968</a></li>
<li><a href="http://agapple.iteye.com/blog/1292129" target="_blank" rel="external">http://agapple.iteye.com/blog/1292129</a></li>
<li><a href="http://stackoverflow.com/questions/17894808/how-do-one-read-the-zookeeper-transaction-log" target="_blank" rel="external">http://stackoverflow.com/questions/17894808/how-do-one-read-the-zookeeper-transaction-log</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下描述中用&lt;strong&gt;zk&lt;/strong&gt;代指&lt;strong&gt;ZooKeeper&lt;/strong&gt;，源码解释均基于&lt;strong&gt;ZooKeeper 3.4.6&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1、背景&quot;&gt;&lt;a href=&quot;#1、背景&quot; class=&quot;he
    
    </summary>
    
      <category term="ZooKeeper" scheme="https://hackbuteers.github.io/categories/ZooKeeper/"/>
    
    
      <category term="ZooKeeper" scheme="https://hackbuteers.github.io/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper - Data Sync</title>
    <link href="https://hackbuteers.github.io/2017/06/14/ZK-Data-Sync/"/>
    <id>https://hackbuteers.github.io/2017/06/14/ZK-Data-Sync/</id>
    <published>2017-06-14T09:11:33.000Z</published>
    <updated>2017-06-16T08:52:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下描述中用<strong>zk</strong>代指<strong>ZooKeeper</strong>，源码解释均基于<strong>ZooKeeper 3.4.6</strong></p>
<h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><p>继上次的<strong>Session</strong>问题后，好学的小冷同学又认真地研究了下<strong>ZooKeeper Cluster</strong>的原理，问了我下面5个问题：</p>
<blockquote>
<ul>
<li><strong>ZooKeeper</strong>集群在发生<strong>Leader</strong>切换的时候，所有的<strong>Follower</strong>会选择新的<strong>Leader</strong>进行全量的数据同步吗？</li>
<li>如果一次写入，由于丢包，导致某条日志没有写入，会怎么样呢？</li>
<li>扩容的时候加了个节点，这时候新的写入会不会同步到这个新节点呢？</li>
<li><strong>Follower</strong>会主动向<strong>Leader</strong>发<strong>ping</strong>包么？</li>
<li>集群在选举的时候，四字命令都会返回<strong>This ZooKeeper instance is not currently serving requests</strong>，什么时候会变回正常可服务状态？</li>
</ul>
</blockquote>
<p>这几个问题我都不太确定，于是，踏上了新一轮的<strong>啃码之旅</strong>。</p>
<h2 id="问题A"><a href="#问题A" class="headerlink" title="问题A"></a>问题A</h2><blockquote>
<p><strong>ZooKeeper</strong>集群在发生<strong>Leader</strong>切换的时候，所有的<strong>Follower</strong>会选择新的<strong>Leader</strong>进行全量的数据同步吗？</p>
</blockquote>
<p>这篇帖子里面的解释是我比较认同：</p>
<blockquote>
<p>1、SNAP-全量同步<br>条件：peerLastZxid<mincommittedlog 说明：证明二者数据差异太大，follower数据过于陈旧，leader发送快照snap指令给follower全量同步数据，即leader将所有数据全量同步到follower="" 2、diff-增量同步="" 条件：mincommittedlog<="peerLastZxid<=maxCommittedLog" 说明：证明二者数据差异不大，follower上有一些leader上已经提交的提议proposal未同步，此时需要增量提交这些提议即可="" 3、trunc-仅回滚同步="" 条件：peerlastzxid="">minCommittedLog<br>说明：证明follower上有些提议proposal并未在leader上提交，follower需要回滚到zxid为minCommittedLog对应的事务操作<br>4、TRUNC+DIFF-回滚+增量同步<br>条件：minCommittedLog&lt;=peerLastZxid&lt;=maxCommittedLog且特殊场景leader a已经将事务truncA提交到本地事务日志中，但没有成功发起proposal协议进行投票就宕机了；然后集群中剔除原leader a重新选举出新leader b，又提交了若干新的提议proposal，然后原leader a重新服务又加入到集群中，不管是否被选举为新leader。<br>说明：此时a,b都有一些对方未提交的事务，若b是leader, a需要先回滚truncA然后增量同步新leader a上的数据</mincommittedlog></p>
</blockquote>
<p>对应的代码在<strong>LearnerHandler.run</strong>中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line">// packetToSend默认为Leader.SNAP</div><div class="line">try &#123;</div><div class="line">    rl.lock();</div><div class="line">    final long maxCommittedLog = leader.zk.getZKDatabase().getmaxCommittedLog();</div><div class="line">    final long minCommittedLog = leader.zk.getZKDatabase().getminCommittedLog();</div><div class="line">    LOG.info(<span class="string">"Synchronizing with Follower sid: "</span> + sid</div><div class="line">            +<span class="string">" maxCommittedLog=0x"</span>+Long.toHexString(maxCommittedLog)</div><div class="line">            +<span class="string">" minCommittedLog=0x"</span>+Long.toHexString(minCommittedLog)</div><div class="line">            +<span class="string">" peerLastZxid=0x"</span>+Long.toHexString(peerLastZxid));</div><div class="line"></div><div class="line">    // ZKDatabase.committedLog是仅存在于内存中的结构，虽然Follower或者Leader退出时，</div><div class="line">    // 会调用ZKDatabase.clear清空内存中的数据，但是FastLeaderElection.getInitLastLoggedZxid</div><div class="line">    // 最终会调用ZKDatabase.loadDataBase重新加载数据到ZKDatabase.committedLog等内存结构中</div><div class="line">    // 当然，ZKDatabase.loadDataBase是把日志文件中的内容加载加这个结构中</div><div class="line">    // 如果加载之前，对应的zk节点刚好是新生成的snapshot，就会导致ZKDatabase.committedLog为空</div><div class="line">    LinkedList&lt;Proposal&gt; proposals = leader.zk.getZKDatabase().getCommittedLog();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (proposals.size() != 0) &#123;</div><div class="line">        LOG.debug(<span class="string">"proposal size is &#123;&#125;"</span>, proposals.size());</div><div class="line">        <span class="keyword">if</span> ((maxCommittedLog &gt;= peerLastZxid)</div><div class="line">                &amp;&amp; (minCommittedLog &lt;= peerLastZxid)) &#123;</div><div class="line">            // 如果Follower的zxid在[minCommittedLog, maxCommittedLog]，说明可能可以通过重新应用Follower上没有的事务日志来恢复数据</div><div class="line">            LOG.debug(<span class="string">"Sending proposals to follower"</span>);</div><div class="line"></div><div class="line">            // as we look through proposals, this variable keeps track of previous</div><div class="line">            // proposal Id.</div><div class="line">            long prevProposalZxid = minCommittedLog;</div><div class="line"></div><div class="line">            // Keep track of whether we are about to send the first packet.</div><div class="line">            // Before sending the first packet, we have to tell the learner</div><div class="line">            // whether to expect a trunc or a diff</div><div class="line">            boolean firstPacket=<span class="literal">true</span>;</div><div class="line"></div><div class="line">            // If we are here, we can use committedLog to sync with</div><div class="line">            // follower. Then we only need to decide whether to</div><div class="line">            // send trunc or not</div><div class="line">            packetToSend = Leader.DIFF;</div><div class="line">            zxidToSend = maxCommittedLog;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (Proposal propose: proposals) &#123;</div><div class="line">                // 遍历ZKDatabase.committedLog中的事务日志，跳过那些已经在Follower上应用过的日志</div><div class="line">                // skip the proposals the peer already has</div><div class="line">                <span class="keyword">if</span> (propose.packet.getZxid() &lt;= peerLastZxid) &#123;</div><div class="line">                    prevProposalZxid = propose.packet.getZxid();</div><div class="line">                    <span class="built_in">continue</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    // If we are sending the first packet, figure out whether to trunc</div><div class="line">                    // <span class="keyword">in</span> <span class="keyword">case</span> the follower has some proposals that the leader doesn<span class="string">'t</span></div><div class="line">                    if (firstPacket) &#123;</div><div class="line">                        firstPacket = false;</div><div class="line">                        // Does the peer have some proposals that the leader hasn't seen yet</div><div class="line">                        <span class="keyword">if</span> (prevProposalZxid &lt; peerLastZxid) &#123;</div><div class="line">                            // send a trunc message before sending the diff</div><div class="line">                            // 如果出现这种情况，我们需要先在Follower上应用Leader.TRUNC，让其回滚到prevProposalZxid的位置</div><div class="line">                            packetToSend = Leader.TRUNC;</div><div class="line">                            zxidToSend = prevProposalZxid;</div><div class="line">                            updates = zxidToSend;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    // 下面这几行语句是针对Follower上没有的事务日志构造出PROPOSAL和COMMIT请求，放到队列中</div><div class="line">                    // 可以注意到，这个时候LearnerHandler的发送线程是还没有启动的，所以对应的FOLLOWER肯定是先响应Leader.DIFF或者Leader.TRUNC请求的</div><div class="line">                    queuePacket(propose.packet);</div><div class="line">                    QuorumPacket qcommit = new QuorumPacket(Leader.COMMIT, propose.packet.getZxid(),</div><div class="line">                            null, null);</div><div class="line">                    queuePacket(qcommit);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (peerLastZxid &gt; maxCommittedLog) &#123;</div><div class="line">            // 如果Follower的zxid比当前的Leader还要大，发送Leader.TRUNC让Follower的事务日志回滚到当前Leader的maxCommittedLog</div><div class="line">            // 和Leader.SNAP一样，Leader.TRUNC会导致对应的Follower调用ZKDatabase.loadDataBase重新加载数据到内存中</div><div class="line">            LOG.debug(<span class="string">"Sending TRUNC to follower zxidToSend=0x&#123;&#125; updates=0x&#123;&#125;"</span>,</div><div class="line">                    Long.toHexString(maxCommittedLog),</div><div class="line">                    Long.toHexString(updates));</div><div class="line"></div><div class="line">            packetToSend = Leader.TRUNC;</div><div class="line">            zxidToSend = maxCommittedLog;</div><div class="line">            updates = zxidToSend;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            // 进入这块代码的条件是peerLastZxid&lt;minCommittedLog，使用默认的packetToSend：Leader.SNAP</div><div class="line">            // 这个条件有一个<span class="keyword">case</span>：在zk集群中加入一个新的节点，这时候如果Leader        的事务日志中有内容，就会进入这个情况</div><div class="line">            LOG.warn(<span class="string">"Unhandled proposal scenario"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (peerLastZxid == leader.zk.getZKDatabase().getDataTreeLastProcessedZxid()) &#123;</div><div class="line">        // 如果ZKDatabase.committedLog为空，而且对应的Follower和当前Leader内存中的数据是一致的，只发送一个Leader.DIFF的请求</div><div class="line">        // 而不进行数据的同步，甚至也没有对应的PROPOSAL/COMMIT请求</div><div class="line">        // The leader may recently take a snapshot, so the committedLog</div><div class="line">        // is empty. We don<span class="string">'t need to send snapshot if the follow</span></div><div class="line">        // is already sync with in-memory db.</div><div class="line">        LOG.debug("committedLog is empty but leader and follower "</div><div class="line">                + "are in sync, zxid=0x&#123;&#125;",</div><div class="line">                Long.toHexString(peerLastZxid));</div><div class="line">        packetToSend = Leader.DIFF;</div><div class="line">        zxidToSend = peerLastZxid;</div><div class="line">    &#125; else &#123;</div><div class="line">        // 如果ZKDatabase.committedLog为空，但是对应的Follower和当前Leader内存中的数据不一致</div><div class="line">        // 这时候会使用默认的packetToSend：Leader.SNAP</div><div class="line">        // just let the state transfer happen</div><div class="line">        LOG.debug("proposals is empty");</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    LOG.info("Sending " + Leader.getPacketType(packetToSend));</div><div class="line">    leaderLastZxid = leader.startForwarding(this, updates);</div><div class="line"></div><div class="line">&#125; finally &#123;</div><div class="line">    rl.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="问题B"><a href="#问题B" class="headerlink" title="问题B"></a>问题B</h2><blockquote>
<p>如果一次写入，由于丢包，导致某条日志没有写入，会怎么样呢？</p>
</blockquote>
<p>先引入上次的<strong>Session</strong>问题中使用过的一张图：<br><a href="https://orimyicvd.bkt.clouddn.com/zk-session.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/zk-session.png"></a><br><strong>Leader</strong>会向<strong>Follower</strong>发送<strong>Proposal</strong>和<strong>Commit</strong>请求，其中，<strong>Follower</strong>收到<strong>Proposal</strong>请求之后，会写入日志；收到<strong>Commit</strong>请求之后，会更改内存中的<strong>DataTree</strong>。<br>问题中提到的日志没有写入，也就是发送到某个<strong>Follower</strong>的<strong>Proposal</strong>请求被丢弃了， 对应的<strong>Follower</strong>会是怎样一个逻辑呢？<br>回答这个问题，最直观的方法就是模拟场景，在实验中将<strong>Proposal</strong>请求丢弃，观察对应的<strong>Follower</strong>和<strong>Leader</strong>的表现。<br>那么，问题来了，如何模拟呢？<br>在<strong>Jepsen</strong>中，使用的是<strong>iptables</strong>来模拟网络故障（周期性地丢包、网络分区等）。在我的模拟环境中，<strong>zk</strong>集群都是部署在本地，使用<strong>iptables</strong>来操作会比较繁琐，而且我的需求是精确地丢弃掉<strong>Proposal</strong>请求，而不是<strong>Follower</strong>和<strong>Leader</strong>之间发送的所有的请求。<br>最终还是使用了<strong>Byteman</strong>，对应的脚本如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">RULE trace zk.skip_proposal_packet</div><div class="line">CLASS org.apache.zookeeper.server.quorum.Follower</div><div class="line">METHOD processPacket</div><div class="line">AT ENTRY</div><div class="line">IF <span class="variable">$1</span>.getType() == 2</div><div class="line">DO</div><div class="line">  traceln(<span class="string">"*** drop PROPOSAL packet"</span>);</div><div class="line">  <span class="built_in">return</span>;</div><div class="line">ENDRULE</div></pre></td></tr></table></figure></p>
<p>使用<strong>Byteman</strong>做故障场景模拟并不是我的原创，<strong>Cassandra</strong>中使用了<strong>Byteman</strong>来做故障场景注入。这种方法的优点是可以完成代码级别在精确错误注入；缺点也很明显，需要待注入服务是运行在<strong>JVM</strong>之上的。<br>进行了场景模拟之后，发现被测的丢弃<strong>Proposal</strong>请求的<strong>Follower</strong>进入了<strong>LOOKING</strong>状态，然后重新加入了集群。原因是<strong>Leader</strong>主动断开了和<strong>Proposal</strong>的连接。<br>那么，为什么<strong>Follower</strong>丢弃<strong>Proposal</strong>请求会导致<strong>Leader</strong>主动断开了和<strong>Proposal</strong>的连接呢？<br>这个逻辑和<strong>LearnerHandler$SyncLimitCheck</strong>有关，<strong>Leader</strong>会定时去调用<strong>LearnerHandler.ping</strong>向<strong>Follower</strong>发送<strong>Leader.PING</strong>请求，逻辑如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void ping() &#123;</div><div class="line">    long id;</div><div class="line">    <span class="keyword">if</span> (syncLimitCheck.check(System.nanoTime())) &#123;</div><div class="line">        synchronized(leader) &#123;</div><div class="line">            id = leader.lastProposed;</div><div class="line">        &#125;</div><div class="line">        QuorumPacket<span class="built_in"> ping </span>= new QuorumPacket(Leader.PING, id, <span class="literal">null</span>, <span class="literal">null</span>);</div><div class="line">        queuePacket(ping);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        LOG.warn(<span class="string">"Closing connection to peer due to transaction timeout."</span>);</div><div class="line">        shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果<strong>Leader</strong>发送出去的<strong>Leader.PROPOSAL</strong>请求在一段时间内（这个时间由<strong>conf/zoo.cfg</strong>中的<strong>syncLimit</strong>决定）没有收到对应的<strong>ACK</strong>，就会导致<strong>syncLimitCheck.check</strong>失败，从而调用<strong>LearnerHandler.shutdown</strong>关闭到这个<strong>Follower</strong>的连接，并停止对应的发送、接收请求的线程。<br>在<strong>Follower</strong>这边，由于<strong>Leader</strong>连接关闭，调用<strong>Learner.readPacket</strong>时会抛出异常，退出<strong>Follower.followLeader</strong>方法，重新进入<strong>LOOKING</strong>状态。<br>综上，我们知道了，发送到某个<strong>Follower</strong>的<strong>Proposal</strong>请求被丢弃，会导致对应的<strong>Follower</strong>重新进入<strong>LOOKING</strong>状态。<br>那么，如果被丢弃的请求是<strong>Commit</strong>请求呢？<br>同样使用<strong>Byteman</strong>进行了模拟，由于<strong>Commit</strong>请求是不需要返回<strong>ACK</strong>给<strong>Leader</strong>的，所以，如果模拟时有两个写入请求<strong>ReqA</strong>、<strong>ReqB</strong>，如果两个请求对应的<strong>Commit</strong>请求都丢弃了，这个时候其实对系统并没有什么影响，但是连接到对应<strong>Follower</strong>上的客户端看到的数据就是<strong>stale</strong>的。<br>如果丢弃<strong>ReqA</strong>对应的<strong>Commit</strong>请求之后就撤销故障场景，<strong>ReqB</strong>对应的<strong>Commit</strong>请求正常执行会是什么情况呢？对应的逻辑在<strong>FollowerZooKeeperServer.commit</strong>中：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span> 收到Leader发送的Leader.COMMIT请求之后，会调用这个方法</div><div class="line">public void commit(long zxid) &#123;</div><div class="line">    <span class="regexp">//</span> FollowerZooKeeperServer.logRequest中会添加条目到pendingTxns中</div><div class="line">    <span class="regexp">//</span> 这个field保存了所有调用了syncProcessor.processRequest，但是没有收到</div><div class="line">    <span class="regexp">//</span> Commit请求的Request</div><div class="line">    <span class="keyword">if</span> (pendingTxns.size() == <span class="number">0</span>) &#123;</div><div class="line">        LOG.warn(<span class="string">"Committing "</span> + Long.toHexString(zxid)</div><div class="line">                + <span class="string">" without seeing txn"</span>);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    <span class="regexp">//</span> 如果收到的Commit请求中的zxid和pendingTxns中第一个请求的zxid是不一样的</div><div class="line">    <span class="regexp">//</span> 打印Error级别的日志并退出java进程</div><div class="line">    <span class="regexp">//</span> 在我们的模拟情况中，pendingTxns中第一个请求是ReqA</div><div class="line">    <span class="regexp">//</span> 所以当ReqB对应的Commit请求被Follower收到时，会进入到这个逻辑</div><div class="line">    long firstElementZxid = pendingTxns.element().zxid;</div><div class="line">    <span class="keyword">if</span> (firstElementZxid != zxid) &#123;</div><div class="line">        LOG.error(<span class="string">"Committing zxid 0x"</span> + Long.toHexString(zxid)</div><div class="line">                + <span class="string">" but next pending txn 0x"</span></div><div class="line">                + Long.toHexString(firstElementZxid));</div><div class="line">        System.<span class="keyword">exit</span>(<span class="number">12</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="regexp">//</span> 如果是匹配的，就从pendingTxns中移除这个请求</div><div class="line">    <span class="regexp">//</span> 并执行commitProcessor.commit</div><div class="line">    Request request = pendingTxns.remove();</div><div class="line">    commitProcessor.commit(request);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>是的，对应的<strong>Follower</strong>进程退出了。</p>
<h2 id="问题C"><a href="#问题C" class="headerlink" title="问题C"></a>问题C</h2><blockquote>
<p>扩容的时候加了个节点，这时候新的写入会不会同步到这个新节点呢？</p>
</blockquote>
<p>会的。虽然这时候<strong>Leader</strong>的<strong>conf/zoo.cfg</strong>里面还没有新加入节点的信息，但是<strong>Leader</strong>会为这个节点创建相应的<strong>LearnerHandler</strong>，对应的逻辑在<strong>Leader$LearnerCnxAcceptor.run</strong>中：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Socket s = ss.accept();</div><div class="line"><span class="comment">// start with the initLimit, once the ack is processed</span></div><div class="line"><span class="comment">// in LearnerHandler switch to the syncLimit</span></div><div class="line">s.setSoTimeout(self.tickTime * self.initLimit);</div><div class="line">s.setTcpNoDelay(nodelay);</div><div class="line">LearnerHandler fh = <span class="keyword">new</span> <span class="type">LearnerHandler</span>(s, Leader.<span class="built_in">this</span>);</div><div class="line">fh.start();</div></pre></td></tr></table></figure></p>
<p>新加入的节点也会经历如下的阶段：<br><a href="https://orimyicvd.bkt.clouddn.com/zk-node.png" data-fancybox="images" target="_blank" rel="external"><img src="https://orimyicvd.bkt.clouddn.com/zk-node.png"></a><br>上图中的步骤是在<strong>Learner.registerWithLeader</strong>和<strong>Learner.syncWithLeader</strong>中完成的，也是新加入节点从<strong>Leader</strong>中同步数据的步骤。再看看<strong>Leader</strong>是如何把增量的数据同步到<strong>Follower</strong>的。<br><strong>Leader</strong>向<strong>Follower</strong>发送请求的方法<strong>Leader.sendPacket</strong>实现如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">void</span> <span class="selector-tag">sendPacket</span>(QuorumPacket qp) &#123;</div><div class="line">    <span class="selector-tag">synchronized</span> (forwardingFollowers) &#123;</div><div class="line">        <span class="selector-tag">for</span> (LearnerHandler <span class="attribute">f </span>: forwardingFollowers) &#123;</div><div class="line">            <span class="selector-tag">f</span><span class="selector-class">.queuePacket</span>(qp);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>新加入节点的<strong>LearnerHandler</strong>是在<strong>LearnerHandler.run</strong>中通过调用<strong>Leader.startForwarding</strong>加入到<strong>Leader.forwardingFollowers</strong>中的，加入之后<strong>Leader</strong>就会开始同步数据到新的节点了。<br>那么，在计算<strong>QuorumVerifier.containsQuorum</strong>的时候，会涉及到新加入的节点么？<br>答案是，某种程度上，会。<br>验证<strong>Ping</strong>或者<strong>Proposal</strong>是否达到大多数的逻辑是在<strong>QuorumPeer.quorumConfig</strong>中实现的。<br><strong>QuorumPeer.quorumConfig</strong>这个<strong>field</strong>对应的类型是<strong>QuorumVerifier</strong>这个接口，这个接口有两个实现：<strong>QuorumMaj</strong>和<strong>QuorumHierarchical</strong>，我们的部署比较简单，没有<strong>weight</strong>相关的配置，所以使用的实现都是<strong>QuorumMaj</strong>。<br><strong>QuorumMaj</strong>中有一个<strong>field</strong>叫<strong>half</strong>，标志着这个集群里面半数的值（对于<strong>3节点</strong>的集群，<strong>half</strong>为<strong>1</strong>；对于<strong>4节点</strong>的集群，<strong>half</strong>为<strong>2</strong>；依此类推）；对应的<strong>containsQuorum</strong>方法实现也非常简单粗暴：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> boolean containsQuorum(HashSet&lt;<span class="built_in">Long</span>&gt; <span class="keyword">set</span>)&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">set</span>.size() &gt; half);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于<strong>QuorumPeer.setQuorumVerifier</strong>只有在节点启动的时候才会被调用，所以<strong>QuorumMaj.half</strong>的值在节点启动之后就不会改变。<br>如果在一个<strong>3节点（zk0、zk1、zk2）</strong>的集群中，扩容一个新节点<strong>zk3</strong>。在没有启动集群原有<strong>3节点</strong>的情况下，<strong>Leader</strong>中的<strong>QuorumMaj.half</strong>会一直为<strong>1</strong>，只是这时候，<strong>containsQuorum</strong>方法的输入可能是一个大小为<strong>4</strong>的集合。<br>可以理解为<strong>Leader</strong>中判断<strong>Proposal</strong>是否达到大多数的标准是没有变化的，但是输入产生了变化。</p>
<h2 id="问题D"><a href="#问题D" class="headerlink" title="问题D"></a>问题D</h2><blockquote>
<p><strong>Follower</strong>会主动向<strong>Leader</strong>发<strong>ping</strong>包么？</p>
</blockquote>
<p>不会，<strong>Follower</strong>向<strong>Leader</strong>发的<strong>Leader.PING</strong>包只是<strong>response</strong>，并没有线程会定期向<strong>Leader</strong>来发。那么，这时候会有个问题，如果<strong>Follower</strong>长时间没有收到<strong>Leader</strong>发的<strong>Leader.PING</strong>请求会怎么样呢？<br>依然是使用<strong>Byteman</strong>将<strong>Leader</strong>发送给<strong>Follower</strong>的<strong>Leader.PING</strong>请求给丢弃掉，对应的脚本如下：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">RULE trace zk.skip_ping</div><div class="line"><span class="keyword">CLASS</span> org.apache.zookeeper.server.quorum.LearnerHandler</div><div class="line"><span class="function"><span class="keyword">METHOD</span> <span class="title">ping</span></span></div><div class="line"><span class="title">AT</span> <span class="title">ENTRY</span></div><div class="line"><span class="title">IF</span> $0.<span class="title">sid</span> == 2</div><div class="line"><span class="title">DO</span></div><div class="line">  <span class="title">traceln</span><span class="params">("*** drop ping packet <span class="keyword">to</span> sid: 2")</span>;</div><div class="line">  return;</div><div class="line">ENDRULE</div></pre></td></tr></table></figure></p>
<p>可以看到对应的<strong>Follower</strong>会不断进入<strong>LOOKING</strong>状态，连上<strong>Leader</strong>之后相隔<strong>10s</strong>就会有如下日志，错误为<strong>Read timed out</strong>：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017</span>-<span class="number">06</span>-<span class="number">12</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">34</span>,<span class="number">963</span> [myid:<span class="number">2</span>] - INFO - Snapshotting: <span class="number">0</span>x100000000 to data/version-<span class="number">2</span>/snapshot.<span class="number">100000000</span></div><div class="line"><span class="number">2017</span>-<span class="number">06</span>-<span class="number">12</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">44</span>,<span class="number">973</span> [myid:<span class="number">2</span>] - WARN - Exception when following the leader</div><div class="line">Exception when following the leader</div><div class="line">java<span class="selector-class">.net</span><span class="selector-class">.SocketTimeoutException</span>: Read timed out</div><div class="line">    ...</div><div class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.Learner</span><span class="selector-class">.readPacket</span>(Learner<span class="selector-class">.java</span>:<span class="number">153</span>)</div><div class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.Follower</span><span class="selector-class">.followLeader</span>(Follower<span class="selector-class">.java</span>:<span class="number">85</span>)</div><div class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.QuorumPeer</span><span class="selector-class">.run</span>(QuorumPeer<span class="selector-class">.java</span>:<span class="number">786</span>)</div></pre></td></tr></table></figure></p>
<p>为什么是<strong>10s</strong>这个时间呢？<br>原因在于<strong>Leader.syncWithLeader</strong>这个方法中，在收到<strong>Leader.UPTODATE</strong>后，会调用：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">sock</span><span class="selector-class">.setSoTimeout</span>(<span class="selector-tag">self</span><span class="selector-class">.tickTime</span> * <span class="selector-tag">self</span><span class="selector-class">.syncLimit</span>);</div></pre></td></tr></table></figure></p>
<p>在<strong>conf/zoo.cfg</strong>中，我们目前的配置为：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># The number of milliseconds of each tick</span></div><div class="line"><span class="attr">tickTime</span>=<span class="number">2000</span></div><div class="line"><span class="comment"># The number of ticks that the initial</span></div><div class="line"><span class="comment"># synchronization phase can take</span></div><div class="line"><span class="attr">initLimit</span>=<span class="number">10</span></div><div class="line"><span class="comment"># The number of ticks that can pass between</span></div><div class="line"><span class="comment"># sending a request and getting an acknowledgement</span></div><div class="line"><span class="attr">syncLimit</span>=<span class="number">5</span></div></pre></td></tr></table></figure></p>
<p>因此，和<strong>Leader</strong>建立的<strong>socket</strong>的读写超时时间为<strong>2000ms * 5 = 10s</strong>。<br>不止<strong>Follower</strong>会超时断连，<strong>Leader</strong>的日志显示<strong>Leader</strong>也会出现读超时：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">2017<span class="selector-tag">-06-12</span> 15<span class="selector-pseudo">:31</span><span class="selector-pseudo">:15</span>,988 <span class="selector-attr">[myid:1]</span> <span class="selector-tag">-</span> <span class="selector-tag">INFO</span> <span class="selector-tag">-</span> <span class="selector-tag">Received</span> <span class="selector-tag">NEWLEADER-ACK</span> <span class="selector-tag">message</span> <span class="selector-tag">from</span> 2</div><div class="line">2017<span class="selector-tag">-06-12</span> 15<span class="selector-pseudo">:31</span><span class="selector-pseudo">:25</span>,994 <span class="selector-attr">[myid:1]</span> <span class="selector-tag">-</span> <span class="selector-tag">ERROR</span> <span class="selector-tag">-</span> <span class="selector-tag">Unexpected</span> <span class="selector-tag">exception</span> <span class="selector-tag">causing</span> <span class="selector-tag">shutdown</span> <span class="selector-tag">while</span> <span class="selector-tag">sock</span> <span class="selector-tag">still</span> <span class="selector-tag">open</span></div><div class="line"><span class="selector-tag">java</span><span class="selector-class">.net</span><span class="selector-class">.SocketTimeoutException</span>: <span class="selector-tag">Read</span> <span class="selector-tag">timed</span> <span class="selector-tag">out</span></div><div class="line">    ...</div><div class="line">    <span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.jute</span><span class="selector-class">.BinaryInputArchive</span><span class="selector-class">.readRecord</span>(<span class="selector-tag">BinaryInputArchive</span><span class="selector-class">.java</span><span class="selector-pseudo">:103)</span></div><div class="line">    <span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.LearnerHandler</span><span class="selector-class">.run</span>(<span class="selector-tag">LearnerHandler</span><span class="selector-class">.java</span><span class="selector-pseudo">:546)</span></div></pre></td></tr></table></figure></p>
<p>然后，关闭对应的<strong>LearnerHandler</strong>。</p>
<h2 id="问题E"><a href="#问题E" class="headerlink" title="问题E"></a>问题E</h2><blockquote>
<p>集群在选举的时候，四字命令都会返回<strong>This ZooKeeper instance is not currently serving requests</strong>，什么时候会变回正常可服务状态？</p>
</blockquote>
<p>先看一下四字命令返回<strong>ZK_NOT_SERVING</strong>的逻辑，以<strong>mntr</strong>这个四字命令为例，对应的代码在<strong>NIOServerCnxn$MonitorCommand.commandRun</strong>中：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorCommand</span> <span class="keyword">extends</span> <span class="title">CommandThread</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="type">MonitorCommand</span>(<span class="type">PrintWriter</span> pw) &#123;</div><div class="line">        <span class="keyword">super</span>(pw);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    public void commandRun() &#123;</div><div class="line">        <span class="keyword">if</span>(zkServer == <span class="literal">null</span>) &#123;</div><div class="line">            pw.println(<span class="type">ZK_NOT_SERVING</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>NIOServerCnxn</strong>这个对象是每个连接都会创建一个的，创建<strong>NIOServerCnxn</strong>对象的逻辑在<strong>NIOServerCnxnFactory.createConnection</strong>中：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="function">NIOServerCnxn <span class="title">createConnection</span><span class="params">(SocketChannel sock,</span></span></div><div class="line">        SelectionKey sk) <span class="keyword">throws</span> IOException &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NIOServerCnxn(zkServer, sock, sk, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>NIOServerCnxn</strong>构造方法参数里面使用的是<strong>ServerCnxnFactory.zkServer</strong>，那么，<strong>ServerCnxnFactory.zkServer</strong>是在什么时候设置的呢？分别看下<strong>Follower</strong>和<strong>Leader</strong>中对应的逻辑。</p>
<h2 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a>Follower</h2><p><strong>Follower</strong>会在收到<strong>Leader</strong>发送的<strong>Leader.UPTODATE</strong>之后去设置，对应的逻辑在<strong>Learner.syncWithLeader</strong>中，调用<strong>ServerCnxnFactory.setZooKeeperServer</strong>来设置<strong>ServerCnxnFactory.zkServer</strong>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> Leader.UPTODATE:</div><div class="line">    <span class="keyword">if</span> (!snapshotTaken) &#123; // <span class="literal">true</span> <span class="keyword">for</span> the pre v1.0 <span class="keyword">case</span></div><div class="line">        zk.takeSnapshot();</div><div class="line">        self.setCurrentEpoch(newEpoch);</div><div class="line">    &#125;</div><div class="line">    self.cnxnFactory.setZooKeeperServer(zk);</div><div class="line">    <span class="built_in">break</span> outerLoop;</div></pre></td></tr></table></figure></p>
<h2 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h2><p><strong>Leader</strong>会在<strong>Leader.leader</strong>中<strong>waitForNewLeaderAck</strong>之后去设置，对应的逻辑如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">    waitForNewLeaderAck(self.getId(), zk.getZxid(), LearnerType.PARTICIPANT);</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">    shutdown(<span class="string">"Waiting for a quorum of followers, only synced with sids: [ "</span></div><div class="line">            + getSidSetString(newLeaderProposal.ackSet) + <span class="string">" ]"</span>);</div><div class="line">    HashSet&lt;Long&gt; followerSet = new HashSet&lt;Long&gt;();</div><div class="line">    <span class="keyword">for</span> (LearnerHandler f : learners)</div><div class="line">        followerSet.add(f.getSid());</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (self.getQuorumVerifier().containsQuorum(followerSet)) &#123;</div><div class="line">        LOG.warn(<span class="string">"Enough followers present. "</span></div><div class="line">                + <span class="string">"Perhaps the initTicks need to be increased."</span>);</div><div class="line">    &#125;</div><div class="line">    Thread.sleep(self.tickTime);</div><div class="line">    self.tick++;</div><div class="line">    <span class="built_in">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">startZkServer();</div><div class="line">...</div><div class="line"><span class="keyword">if</span> (!System.getProperty(<span class="string">"zookeeper.leaderServes"</span>, <span class="string">"yes"</span>).equals(<span class="string">"no"</span>)) &#123;</div><div class="line">    self.cnxnFactory.setZooKeeperServer(zk);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码里面可以看到，调用<strong>ServerCnxnFactory.setZooKeeperServer</strong>的前提是<strong>zookeeper.leaderServes</strong>这个属性是设置为<strong>true</strong>的（默认为<strong>true</strong>）。这个属性的含义是，<strong>Leader</strong>节点是否接受客户端的请求。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这些细节在实际维护中应用到的比较少，维护中会遇到的问题可能是“我的<strong>snap</strong>太多了，应该怎么清理”、“我想给某个包加个自定义的日志级别怎么办”、“我的<strong>Curator</strong>报这个错是什么意思”。虽然如此，我比较认可的观点仍然是：</p>
<blockquote>
<p>维护开源产品不了解源码，或者没有找到看的有效入口，是很被动的，缺少定位解决问题的根本手段</p>
</blockquote>
<p>有了源码定位以及相关工具的经验，遇到问题才不会轻易<strong>方</strong>、不会轻易<strong>炸毛</strong>、不会轻易<strong>甩锅</strong>。当这些代码不再是坨翔而是<strong>My precious</strong>时，解决问题就变成一种愉悦的体验了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://sel-fish.net/2017/04/28/mongodb-slow-query/" target="_blank" rel="external">http://sel-fish.net/2017/04/28/mongodb-slow-query/</a></li>
<li><a href="http://blog.csdn.net/xiaofengcanyuexj/article/details/52555230" target="_blank" rel="external">http://blog.csdn.net/xiaofengcanyuexj/article/details/52555230</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下描述中用&lt;strong&gt;zk&lt;/strong&gt;代指&lt;strong&gt;ZooKeeper&lt;/strong&gt;，源码解释均基于&lt;strong&gt;ZooKeeper 3.4.6&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1、背景&quot;&gt;&lt;a href=&quot;#1、背景&quot; class=&quot;he
    
    </summary>
    
      <category term="ZooKeeper" scheme="https://hackbuteers.github.io/categories/ZooKeeper/"/>
    
    
      <category term="ZooKeeper" scheme="https://hackbuteers.github.io/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>Hexo添加百度统计流程</title>
    <link href="https://hackbuteers.github.io/2017/06/14/tongji/"/>
    <id>https://hackbuteers.github.io/2017/06/14/tongji/</id>
    <published>2017-06-14T06:58:36.000Z</published>
    <updated>2017-06-16T08:52:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>今天介绍一下<code>hexo</code>中如何使用统计插件，每天看到自己的博客访问量越来越高也是一种享受。</p>
<h2 id="2、正文"><a href="#2、正文" class="headerlink" title="2、正文"></a>2、正文</h2><ul>
<li>1、现在百度统计官网，注册一个账号，并且绑定好域名。</li>
<li>2、再复制hm.js后面的字符串如图：<br><a href="http://orimyicvd.bkt.clouddn.com/tongji.png" data-fancybox="images" target="_blank" rel="external"><img src="http://orimyicvd.bkt.clouddn.com/tongji.png"></a></li>
<li><p>3、编辑主题配置文件， 修改字段 baidu_analytics，值设置成你的百度统计脚本id。<br><a href="http://orimyicvd.bkt.clouddn.com/baiduId.png" data-fancybox="images" target="_blank" rel="external"><img src="http://orimyicvd.bkt.clouddn.com/baiduId.png"></a><br>至此完成。</p>
</li>
<li><p>4、刚开始我以为是我的网站上可以看到百度统计的结果。原本是要到百度统计官网去看。<br><a href="http://orimyicvd.bkt.clouddn.com/correct.png" data-fancybox="images" target="_blank" rel="external"><img src="http://orimyicvd.bkt.clouddn.com/correct.png"></a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;headerlink&quot; title=&quot;1、前言&quot;&gt;&lt;/a&gt;1、前言&lt;/h2&gt;&lt;p&gt;今天介绍一下&lt;code&gt;hexo&lt;/code&gt;中如何使用统计插件，每天看到自己的博客访问量越来越高也是一种享受。&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="hexo" scheme="https://hackbuteers.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://hackbuteers.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Intellij IDEA 配置Tomcat远程调试</title>
    <link href="https://hackbuteers.github.io/2017/06/13/idea_debug/"/>
    <id>https://hackbuteers.github.io/2017/06/13/idea_debug/</id>
    <published>2017-06-13T12:36:32.000Z</published>
    <updated>2017-06-16T08:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>在服务器端开发过程中，由于服务器环境差异导致运行结果不符合预期。<br>所以就需要用到IDEA Debug 服务器代码，看起来貌似很高大上的事情。<br>今天就说说使用Intellij IDEA 配置Debug的方法。</p>
<h2 id="2、环境和要求"><a href="#2、环境和要求" class="headerlink" title="2、环境和要求"></a>2、环境和要求</h2><p>IDEA：Intellij IDEA 2017.1.1<br>Web服务端：Tomcat 7.0.42</p>
<h3 id="3、服务器Tomcat配置"><a href="#3、服务器Tomcat配置" class="headerlink" title="3、服务器Tomcat配置"></a>3、服务器Tomcat配置</h3><p>找到Tomcat的bin目录，编辑/bin/catalina.sh<br>添加如下命令行<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">CATALINA_OPTS</span>=<span class="string">"-Xdebug -Xrunjdwp:transport=dt_socket,address=60222,suspend=n,server=y"</span></div></pre></td></tr></table></figure></p>
<p><a href="http://orimyicvd.bkt.clouddn.com/tom" data-fancybox="images" target="_blank" rel="external"><img src="http://orimyicvd.bkt.clouddn.com/tom"></a></p>
<h3 id="4、客户端IDEA配置"><a href="#4、客户端IDEA配置" class="headerlink" title="4、客户端IDEA配置"></a>4、客户端IDEA配置</h3><p>配置Intellij IDEA，首先为项目添加一个Remote Tomcat<br><a href="http://orimyicvd.bkt.clouddn.com/remote.png" data-fancybox="images" target="_blank" rel="external"><img src="http://orimyicvd.bkt.clouddn.com/remote.png"></a><br>加入项目，配置jvm debug监听的端口<br><a href="http://orimyicvd.bkt.clouddn.com/iedq.png" data-fancybox="images" target="_blank" rel="external"><img src="http://orimyicvd.bkt.clouddn.com/iedq.png"></a><br><a href="http://orimyicvd.bkt.clouddn.com/startUp.png" data-fancybox="images" target="_blank" rel="external"><img src="http://orimyicvd.bkt.clouddn.com/startUp.png"></a><br>tocat的bin路径下catalina.sh中添加的那行代码的端口号，必须要和下面的三个端口号一样，否则无法远程调试。<br><a href="http://orimyicvd.bkt.clouddn.com/debug.png" data-fancybox="images" target="_blank" rel="external"><img src="http://orimyicvd.bkt.clouddn.com/debug.png"></a><br>启动本地的tomcat，开始调试，或者点击右上角的一个小图标按钮也是OK的<br><a href="http://orimyicvd.bkt.clouddn.com/hits.png" data-fancybox="images" target="_blank" rel="external"><img src="http://orimyicvd.bkt.clouddn.com/hits.png"></a><br>本地tomcat会打印如下日志：<br><a href="http://orimyicvd.bkt.clouddn.com/target.png" data-fancybox="images" target="_blank" rel="external"><img src="http://orimyicvd.bkt.clouddn.com/target.png"></a><br>（切记：远程tomcat 调试，必须要把对应的war包拷贝到webapps目录下，否则只是链接指定到某个工程下的target目录下，是无法远程调试的。）<br>提示：Connected to the target VM, address: ‘10.11.2.128:60222’, transport: ‘socket’，说明远程调试已经连接成功了。</p>
<p>如下命令可以查看对应端口占用情况<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lsof -<span class="selector-tag">i</span>:<span class="number">60222</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;headerlink&quot; title=&quot;1、前言&quot;&gt;&lt;/a&gt;1、前言&lt;/h2&gt;&lt;p&gt;在服务器端开发过程中，由于服务器环境差异导致运行结果不符合预期。&lt;br&gt;所以就需要用到IDEA Debug 服务器代码，看起
    
    </summary>
    
      <category term="IDEA" scheme="https://hackbuteers.github.io/categories/IDEA/"/>
    
    
      <category term="IDEA" scheme="https://hackbuteers.github.io/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Linux机器之间互相免登陆</title>
    <link href="https://hackbuteers.github.io/2017/06/08/linux-login/"/>
    <id>https://hackbuteers.github.io/2017/06/08/linux-login/</id>
    <published>2017-06-08T02:52:59.000Z</published>
    <updated>2017-06-16T08:52:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>A为某台Linux主机(机器Ip:10.19.17.28);<br>B为远程主机(机器Ip:10.11.8.25);<br>A和B的系统都是Linux，最终实现A主机免登陆到目标B主机。</p>
<h2 id="1、生成公钥和私钥"><a href="#1、生成公钥和私钥" class="headerlink" title="1、生成公钥和私钥"></a>1、生成公钥和私钥</h2><h3 id="在A机器上执行命令"><a href="#在A机器上执行命令" class="headerlink" title="在A机器上执行命令"></a>在A机器上执行命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa</div></pre></td></tr></table></figure>
<p>默认在 ~/.ssh目录生成两个文件：<br>id_rsa      ：私钥<br>id_rsa.pub  ：公钥</p>
<p>将公钥信息拷贝到目标B机器上面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ scp ~/.ssh/id_rsa.pub mapp@10.11.8.25:.ssh/id_rsa.pub (需要输入密码)</div></pre></td></tr></table></figure></p>
<h3 id="2、导入公钥到认证文件，更改权限-在B机器上执行的命令"><a href="#2、导入公钥到认证文件，更改权限-在B机器上执行的命令" class="headerlink" title="2、导入公钥到认证文件，更改权限(在B机器上执行的命令)"></a>2、导入公钥到认证文件，更改权限(在B机器上执行的命令)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ touch /mapp/.ssh/authorized_keys (如果已经存在这个文件, 跳过这条)</div><div class="line">$ chmod 600 ~/.ssh/authorized_keys  (<span class="comment"># 注意： 必须将~/.ssh/authorized_keys的权限改为600, 该文件用于保存ssh客户端生成的公钥，可以修改服务器的ssh服务端配置文件/etc/ssh/sshd_config来指定其他文件名）</span></div><div class="line">$ cat /mapp/.ssh/id_rsa.pub  &gt;&gt; /mapp/.ssh/authorized_keys (将id_rsa.pub的内容追加到 authorized_keys 中, 注意不要用 &gt; ，否则会清空原有的内容，使其他人无法使用原有的密钥登录)</div></pre></td></tr></table></figure>
<h3 id="3、回到A机器，执行命令，直接进行免登陆跳转"><a href="#3、回到A机器，执行命令，直接进行免登陆跳转" class="headerlink" title="3、回到A机器，执行命令，直接进行免登陆跳转"></a>3、回到A机器，执行命令，直接进行免登陆跳转</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh mapp@10.11.8.25 -p 10022</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;A为某台Linux主机(机器Ip:10.19.17.28);&lt;br&gt;B为远程主机(机器Ip:10.11.8.25);&lt;br&gt;A和B的系统都是Linux，最终实现A主机免登陆到目标B主机。&lt;/p&gt;
&lt;h2 id=&quot;1、生成公钥和私钥&quot;&gt;&lt;a href=&quot;#1、生成公钥和私钥&quot;
    
    </summary>
    
      <category term="Linux" scheme="https://hackbuteers.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://hackbuteers.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
